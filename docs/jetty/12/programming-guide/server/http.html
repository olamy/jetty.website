<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP Server Libraries :: Eclipse Jetty</title>
    <link rel="canonical" href="https://jetty.org/docs/jetty/12/programming-guide/server/http.html">
    <link rel="prev" href="index.html">
    <link rel="next" href="http2.html">
    <meta name="generator" content="Antora 3.1.7">
    <link rel="stylesheet" href="../../../../../_/css/site.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VS4ZRD6HVM"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-VS4ZRD6HVM')</script>
    <link rel="icon" href="../../../../../_/img/favicon.ico" type="image/x-icon"/>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item logo" href="https://jetty.org"><img src="../../../../../_/img/jetty-logo.svg" alt="Eclipse Jetty" width="120"></a>
      <a class="navbar-item" href="https://jetty.org">Eclipse Jetty</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item search hide-for-print">
          <div id="search-field" class="field">
            <input id="search-input" type="text" placeholder="Search the docs">
          </div>
        </div>
        <a class="navbar-item" href="../../../../index.html">Documentation</a>
        <a class="navbar-item" href="../../../../../support.html">Support</a>
        <!--a class="navbar-item" href="../../../../../community.html">Community</a-->
        <a class="navbar-item" href="../../../../../security.html">Security</a>
        <a class="navbar-item" href="../../../../../download.html">Download</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Links</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://github.com/jetty/jetty.project">Source Code</a>
            <a class="navbar-item" href="https://github.com/jetty/jetty.project/issues">Issues</a>
            <a class="navbar-item" href="../../../../contribution-guide/index.html">Contributing</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jetty" data-version="12">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../../index.html">Eclipse Jetty</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../operations-guide/index.html">Operations Guide</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/begin/index.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/features/index.html">Eclipse Jetty Features</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/howtos/index.html">Eclipse Jetty How-Tos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/arch/index.html">Architecture Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../operations-guide/start/index.html">Jetty Start Mechanism</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../operations-guide/start/start-jpms.html">Starting Jetty using JPMS</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../operations-guide/modules/index.html">Jetty Modules</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../operations-guide/modules/custom.html">Custom Jetty Modules</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../operations-guide/modules/standard.html">Standard Modules</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/deploy/index.html">Web Application Deployment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/server/index.html">Jetty Server</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/protocols/index.html">Jetty Connectors and Protocols</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/keystore/index.html">Configuring SSL/TLS KeyStores</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/session/index.html">HTTP Session Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/quickstart/index.html">Faster Web Application Deployment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/annotations/index.html">Annotations</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jsp/index.html">Java Server Pages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jstl/index.html">JavaServer Pages Standard Tag Libraries</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jsf-taglibs/index.html">JavaServer Faces TagLibs</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jndi/index.html">JNDI</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jaas/index.html">JAAS</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jaspi/index.html">JASPI</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jmx/index.html">JMX Monitoring &amp; Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/tools/index.html">Jetty Tools</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/troubleshooting/index.html">Troubleshooting</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/xml/index.html">Jetty XML</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../index.html">Programming Guide</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../client/index.html">Client Libraries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/io-arch.html">I/O Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/http.html">HTTP Client</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/http2.html">HTTP/2 Client Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/http3.html">HTTP/3 Client Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/websocket.html">WebSocket Client</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Server Libraries</a>
<ul class="nav-list">
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="http.html">HTTP Server Libraries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="http2.html">HTTP/2 Server Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="http3.html">HTTP/3 Server Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="compliance.html">Server Compliance Modes</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="session.html">HTTP Session Management</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="websocket.html">WebSocket Server</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="fastcgi.html">FastCGI Server Libraries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="io-arch.html">Server I/O Architecture</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Maven and Jetty</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../maven-jetty/jetty-maven-helloworld.html">Using Maven</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../maven-jetty/jetty-maven-plugin.html">Using the Jetty Maven Plugin</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../maven-jetty/jetty-jspc-maven-plugin.html">Jetty Jspc Maven Plugin</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jetty Architecture</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/bean.html">Jetty Component Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/threads.html">Jetty Threading Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/io.html">Jetty I/O Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/listener.html">Jetty Listeners</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/jmx.html">Jetty JMX Support</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../troubleshooting/index.html">Troubleshooting Jetty</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/logging.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/thread-dump.html">JVM Thread Dump</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/state-tracking.html"><code>StateTrackingHandler</code></a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/component-dump.html">Component Tree Dump</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/debugging.html">Remote Debugging</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Migration Guides</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../migration/94-to-10.html">Migrating from Jetty 9.4.x to Jetty 10.0.x</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../migration/11-to-12.html">Migrating from Jetty 11.0.x to Jetty 12.0.x</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Eclipse Jetty</span>
    <span class="version">12</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../../contribution-guide/index.html">Contribution Guide</a></div>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../../index.html">Eclipse Jetty</a></div>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../../index.html">12</a>
        </li>
        <li class="version">
          <a href="../../../11/index.html">11</a>
        </li>
        <li class="version">
          <a href="../../../10/index.html">10</a>
        </li>
      </ul>
    </li>
    </li>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Eclipse Jetty</a></li>
    <li><a href="../index.html">Programming Guide</a></li>
    <li><a href="index.html">Server Libraries</a></li>
    <li><a href="http.html">HTTP Server Libraries</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">12</button>
  <div class="version-menu">
    <a class="version is-current" href="http.html">12</a>
    <a class="version" href="../../../11/programming-guide/server/http.html">11</a>
    <a class="version" href="../../../10/programming-guide/server/http.html">10</a>
  </div>
</div>
<div class="edit-this-page"><a href="https://github.com/jetty/jetty.project/edit/jetty-12.0.x/documentation/jetty/modules/programming-guide/pages/server/http.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Page Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">HTTP Server Libraries</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Web application development typically involves writing your web applications, packaging them into a web application archive, the <code>*.war</code> file, and then deploy the <code>*.war</code> file into a standalone Servlet Container that you have previously installed.</p>
</div>
<div class="paragraph">
<p>The Jetty server libraries allow you to write web applications components using either the Jetty APIs (by writing <a href="#handler">Jetty <code>Handler</code>s</a>) or using the standard <a href="#handler-use-servlet">Servlet APIs</a> (by writing <code>Servlet</code>s and Servlet <code>Filter</code>s).
These components can then be programmatically assembled together, without the need of creating a <code>*.war</code> file, added to a Jetty <code>Server</code> instance that is then started.
This result in your web applications to be available to HTTP clients as if you deployed your <code>*.war</code> files in a standalone Jetty server.</p>
</div>
<div class="paragraph">
<p>Jetty <code>Handler</code> APIs pros:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Simple minimalist asynchronous APIs.</p>
</li>
<li>
<p>Very low overhead, only configure the features you use.</p>
</li>
<li>
<p>Faster turnaround to implement new APIs or new standards.</p>
</li>
<li>
<p>Normal classloading behavior (web application classloading isolation also available).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Servlet APIs pros:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Standard, well known, APIs.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;
  &lt;version&gt;12.0.10-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>org.eclipse.jetty.server.Server</code> instance is the central component that links together a collection of <code>Connector</code>s and a collection of <code>Handler</code>s, with threads from a <code>ThreadPool</code> doing the work.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/plantuml/svg/eNpNjEEOwjAMBO95hT9QJA68oBeOSPABNzZN1MSu7BS-T1ClqrfdndH6kmVFwwoTxmU23YRGLWrQDMU7YmnBD6uqaEymlbuw8Yl4QtJvlhneWPxMViT677cQPGJhuF56TJkYKteJzfcSs8XCITzZPmwwwCsZIz1USxhVhGNT877vwuENcEeh0n9-7GpJ2w==" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>The components that accept connections from clients are <code>org.eclipse.jetty.server.Connector</code> implementations.</p>
</div>
<div class="paragraph">
<p>When a Jetty server interprets the HTTP protocol (HTTP/1.1, HTTP/2 or HTTP/3), it uses <code>org.eclipse.jetty.server.Handler</code> instances to process incoming requests and eventually produce responses.</p>
</div>
<div class="paragraph">
<p>A <code>Server</code> must be created, configured and started:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create and configure a ThreadPool.
QueuedThreadPool threadPool = new QueuedThreadPool();
threadPool.setName("server");

// Create a Server instance.
Server server = new Server(threadPool);

// Create a ServerConnector to accept connections from clients.
Connector connector = new ServerConnector(server);

// Add the Connector to the Server
server.addConnector(connector);

// Set a simple Handler to handle requests/responses.
server.setHandler(new Handler.Abstract()
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Succeed the callback to signal that the
        // request/response processing is complete.
        callback.succeeded();
        return true;
    }
});

// Start the Server to start accepting connections from clients.
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows the simplest HTTP/1.1 server; it has no support for HTTP sessions, nor for HTTP authentication, nor for any of the features required by the Servlet specification.</p>
</div>
<div class="paragraph">
<p>These features (HTTP session support, HTTP authentication support, etc.) are provided by the Jetty server libraries, but not all of them may be necessary in your web application.
You need to put together the required Jetty components to provide the features required by your web applications.
The advantage is that you do not pay the cost for features that you do not use, saving resources and likely increasing performance.</p>
</div>
<div class="paragraph">
<p>The built-in <code>Handler</code>s provided by the Jetty server libraries allow you to write web applications that have functionalities similar to Apache HTTPD or Nginx (for example: URL redirection, URL rewriting, serving static content, reverse proxying, etc.), as well as generating content dynamically by processing incoming requests.
Read <a href="#handler">this section</a> for further details about <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>If you are interested in writing your web application based on the Servlet APIs, jump to <a href="#handler-use-servlet">this section</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="request-processing"><a class="anchor" href="#request-processing"></a>Request Processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Jetty HTTP request processing is outlined below in the diagram below.
You may want to refer to the <a href="../arch/io.html" class="xref page">Jetty I/O architecture</a> for additional information about the classes mentioned below.</p>
</div>
<div class="paragraph">
<p>Request handing is slightly different for each protocol; in HTTP/2 Jetty takes into account multiplexing, something that is not present in HTTP/1.1.</p>
</div>
<div class="paragraph">
<p>However, the diagram below captures the essence of request handling that is common among all protocols that carry HTTP requests.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/plantuml/svg/eNplkcFOwzAQRO_-Ch_hwA9w4BKBuCBV9Au28Tax6uwG22nF3zNNo8QOl8iaNzNeb9LFy0iRBnui9tJFncQ1GjTaHEkSEEs2aXUNKtr2UQeGYeKCpJ6c3rx09kwhsTGQs2_9SJLtFwl17I4cuM0aK_Yu7qAet5RioyKwepVKPlBMXMc_cx6POTIN_-SmJ7SESj9yvO4bSFzgmIzZjWlf3tbp7KvFHW7-_JpVhWMbFR6VDx8CnQI_PZuC1E1neMC3lqpml3u8GanxfkBsEYC2twPzFb8q7cLFGubpvvln4pTRUhIYH3uBp5-3AcOi3EuWBRX0DxQ5yio=" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>First, the Jetty I/O layer emits an event that a socket has data to read.
This event is converted to a call to <code>AbstractConnection.onFillable()</code>, where the <code>Connection</code> first reads from the <code>EndPoint</code> into a <code>ByteBuffer</code>, and then calls a protocol specific parser to parse the bytes in the <code>ByteBuffer</code>.</p>
</div>
<div class="paragraph">
<p>The parser emit events that are protocol specific; the HTTP/2 parser, for example, emits events for each HTTP/2 frame that has been parsed, and similarly does the HTTP/3 parser.
The parser events are then converted to protocol independent events such as <em>"request start"</em>, <em>"request headers"</em>, <em>"request content chunk"</em>, etc. detailed in <a href="#request-processing-events">this section</a>.</p>
</div>
<div class="paragraph">
<p>When enough of the HTTP request is arrived, the <code>Connection</code> calls <code>HttpChannel.onRequest()</code>.</p>
</div>
<div class="paragraph">
<p><code>HttpChannel.onRequest()</code> calls the <a href="#request-customizers">request customizers</a>, that allow to customize the request and/or the response headers on a per-<code>Connector</code> basis.</p>
</div>
<div class="paragraph">
<p>After request customization, if any, the <code>Handler</code> chain is invoked, starting from the <code>Server</code> instance, and eventually your web application code is invoked.</p>
</div>
<div class="sect2">
<h3 id="request-processing-events"><a class="anchor" href="#request-processing-events"></a>Request Processing Events</h3>
<div class="paragraph">
<p>Advanced web applications may be interested in the progress of the processing of an HTTP request/response.
A typical case is to know exactly <em>when</em> the HTTP request/response processing starts and when it is complete, for example to monitor processing times.</p>
</div>
<div class="paragraph">
<p>This is conveniently implemented by <code>org.eclipse.jetty.server.handler.EventsHandler</code>, described in more details in <a href="#handler-use-events">this section</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="request-logging"><a class="anchor" href="#request-logging"></a>Request Logging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP requests and responses can be logged to provide data that can be later analyzed with other tools.
These tools can provide information such as the most frequently accessed request URIs, the response status codes, the request/response content lengths, geographical information about the clients, etc.</p>
</div>
<div class="paragraph">
<p>The default request/response log line format is the <a href="https://en.wikipedia.org/wiki/Common_Log_Format">NCSA Format</a> extended with referrer data and user-agent data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Typically, the extended NCSA format is the is enough and it&#8217;s the standard used and understood by most log parsing tools and monitoring tools.</p>
</div>
<div class="paragraph">
<p>To customize the request/response log line format see the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/CustomRequestLog.html"><code>CustomRequestLog</code> javadocs</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Request logging can be enabled at the <code>Server</code> level.</p>
</div>
<div class="paragraph">
<p>The request logging output can be directed to an SLF4J logger named <code>"org.eclipse.jetty.server.RequestLog"</code> at <code>INFO</code> level, and therefore to any logging library implementation of your choice (see also <a href="../troubleshooting/logging.html" class="xref page">this section</a> about logging).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Sets the RequestLog to log to an SLF4J logger named "org.eclipse.jetty.server.RequestLog" at INFO level.
server.setRequestLog(new CustomRequestLog(new Slf4jRequestLogWriter(), CustomRequestLog.EXTENDED_NCSA_FORMAT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the request logging output can be directed to a daily rolling file of your choice, and the file name must contain <code>yyyy_MM_dd</code> so that rolled over files retain their date:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Use a file name with the pattern 'yyyy_MM_dd' so rolled over files retain their date.
RequestLogWriter logWriter = new RequestLogWriter("/var/log/yyyy_MM_dd.jetty.request.log");
// Retain rolled over files for 2 weeks.
logWriter.setRetainDays(14);
// Log times are in the current time zone.
logWriter.setTimeZone(TimeZone.getDefault().getID());

// Set the RequestLog to log to the given file, rolling over at midnight.
server.setRequestLog(new CustomRequestLog(logWriter, CustomRequestLog.EXTENDED_NCSA_FORMAT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>For maximum flexibility, you can log to multiple <code>RequestLog</code>s using class <code>RequestLog.Collection</code>, for example by logging with different formats or to different outputs.</p>
</div>
<div class="paragraph">
<p>You can use <code>CustomRequestLog</code> with a custom <code>RequestLog.Writer</code> to direct the request logging output to your custom targets (for example, an RDBMS).
You can implement your own <code>RequestLog</code> if you want to have functionalities that are not implemented by <code>CustomRequestLog</code>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="request-customizers"><a class="anchor" href="#request-customizers"></a>Request Customizers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A request customizer is an instance of <code>HttpConfiguration.Customizer</code>, that can customize the HTTP request and/or the HTTP response headers <em>before</em> the <code>Handler</code> chain is invoked.</p>
</div>
<div class="paragraph">
<p>Request customizers are added to a particular <code>HttpConfiguration</code> instance, and therefore are specific to a <code>Connector</code> instance: you can have two different <code>Connector</code>s configured with different request customizers.</p>
</div>
<div class="paragraph">
<p>For example, it is common to configure a secure <code>Connector</code> with the <code>SecureRequestCustomizer</code> that customizes the HTTP request by adding attributes that expose TLS data associated with the secure communication.</p>
</div>
<div class="paragraph">
<p>A request customizer may:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Inspect the received HTTP request method, URI, version and headers.</p>
</li>
<li>
<p>Wrap the <code>Request</code> object to allow any method to be overridden and customized. Typically this is done to synthesize additional HTTP request headers, or to change the return value of overridden methods.</p>
</li>
<li>
<p>Add or modify the HTTP response headers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The out-of-the-box request customizers include:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>ForwardedRequestCustomizer</code>&#8201;&#8212;&#8201;to interpret the <code>Forwarded</code> (or the the obsolete <code>X-Forwarded-*</code>) HTTP header added by a reverse proxy; see <a href="#request-customizer-forwarded">this section</a>.</p>
</li>
<li>
<p><code>HostHeaderCustomizer</code>&#8201;&#8212;&#8201;to customize, or synthesize it when original absent, the HTTP <code>Host</code> header; see <a href="#request-customizer-host">this section</a>.</p>
</li>
<li>
<p><code>ProxyCustomizer</code>&#8201;&#8212;&#8201;to expose as <code>Request</code> attributes the <code>ip:port</code> information carried by the PROXY protocol; see <a href="#request-customizer-proxy">this section</a>.</p>
</li>
<li>
<p><code>RewriteCustomizer</code>&#8201;&#8212;&#8201;to rewrite the request URI; see <a href="#request-customizer-rewrite">this section</a>.</p>
</li>
<li>
<p><code>SecureRequestCustomizer</code>&#8201;&#8212;&#8201;to expose TLS data via <code>Request</code> attributes; see <a href="#request-customizer-secure">this section</a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>You can also write your own request customizers and add them to the <code>HttpConfiguration</code> instance along existing request customizers.
Multiple request customizers will be invoked in the order they have been added.</p>
</div>
<div class="paragraph">
<p>Below you can find an example of how to add a request customizer:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Configure the secure connector.
HttpConfiguration httpsConfig = new HttpConfiguration();

// Add the SecureRequestCustomizer.
httpsConfig.addCustomizer(new SecureRequestCustomizer());

// Configure the SslContextFactory with the KeyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");
// Configure the Connector to speak HTTP/1.1 and HTTP/2.
HttpConnectionFactory h1 = new HttpConnectionFactory(httpsConfig);
HTTP2ServerConnectionFactory h2 = new HTTP2ServerConnectionFactory(httpsConfig);
ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory();
alpn.setDefaultProtocol(h1.getProtocol());
SslConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, alpn.getProtocol());
ServerConnector connector = new ServerConnector(server, ssl, alpn, h2, h1);
server.addConnector(connector);

server.start();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="request-customizer-forwarded"><a class="anchor" href="#request-customizer-forwarded"></a><code>ForwardedRequestCustomizer</code></h3>
<div class="paragraph">
<p><code>ForwardedRequestCustomizer</code> should be added when Jetty receives requests from a reverse proxy on behalf of a remote client, and web applications need to access the remote client information.</p>
</div>
<div class="paragraph">
<p>The reverse proxy adds the <code>Forwarded</code> (or the obsolete <code>X-Forwarded-*</code>) HTTP header to the request, and may offload TLS so that the request arrives in clear-text to Jetty.</p>
</div>
<div class="paragraph">
<p>Applications deployed in Jetty may need to access information related to the remote client, for example the remote IP address and port, or whether the request was sent through a secure communication channel.
However, the request is forwarded by the reverse proxy, so the direct information about the remote IP address is that of the proxy, not of the remote client.
Furthermore, the proxy may offload TLS and forward the request in clear-text, so that the URI scheme would be <code>http</code> as forwarded by the reverse proxy, not <code>https</code> as sent by the remote client.</p>
</div>
<div class="paragraph">
<p><code>ForwardedRequestCustomizer</code> reads the <code>Forwarded</code> header where the reverse proxy saved the remote client information, and wraps the original <code>Request</code> so that applications will transparently see the remote client information when calling methods such as <code>Request.isSecure()</code>, or <code>Request.getConnectionMetaData().getRemoteSocketAddress()</code>, etc.</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>ForwardedRequestCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ForwardedRequestCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="request-customizer-host"><a class="anchor" href="#request-customizer-host"></a><code>HostHeaderCustomizer</code></h3>
<div class="paragraph">
<p><code>HostHeaderCustomizer</code> should be added when Jetty receives requests that may lack the <code>Host</code> HTTP header, such as HTTP/1.0, HTTP/2 or HTTP/3 requests, and web applications have logic that depends on the value of the <code>Host</code> HTTP header.</p>
</div>
<div class="paragraph">
<p>For HTTP/2 and HTTP/3, the <code>Host</code> HTTP header is missing because the authority information is carried by the <code>:authority</code> pseudo-header, as per the respective specifications.</p>
</div>
<div class="paragraph">
<p><code>HostHeaderCustomizer</code> will look at the <code>:authority</code> pseudo-header, then wrap the original <code>Request</code> adding a <code>Host</code> HTTP header synthesized from the <code>:authority</code> pseudo-header.
In this way, web applications that rely on the presence of the <code>Host</code> HTTP header will work seamlessly in any HTTP protocol version.</p>
</div>
<div class="paragraph">
<p><code>HostHeaderCustomizer</code> works also for the WebSocket protocol.</p>
</div>
<div class="paragraph">
<p>WebSocket over HTTP/2 or over HTTP/3 initiate the WebSocket communication with an HTTP request that only has the <code>:authority</code> pseudo-header.
<code>HostHeaderCustomizer</code> synthesizes the <code>Host</code> HTTP header for such requests, so that WebSocket web applications that inspect the initial HTTP request before the WebSocket communication will work seamlessly in any HTTP protocol version.</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>HostHeaderCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/HostHeaderCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="request-customizer-proxy"><a class="anchor" href="#request-customizer-proxy"></a><code>ProxyCustomizer</code></h3>
<div class="paragraph">
<p><code>ProxyCustomizer</code> should be added when Jetty receives requests from a reverse proxy on behalf of a remote client, prefixed by the PROXY protocol (see also this section about the <a href="#connector-protocol-proxy-http11">PROXY protocol</a>).</p>
</div>
<div class="paragraph">
<p><code>ProxyCustomizer</code> adds the reverse proxy IP address and port as <code>Request</code> attributes.
Web applications may use these attributes in conjunction with the data exposed by <code>ForwardedRequestCustomizer</code> (see <a href="#request-customizer-forwarded">this section</a>).</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>ProxyCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/ProxyCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="request-customizer-rewrite"><a class="anchor" href="#request-customizer-rewrite"></a><code>RewriteCustomizer</code></h3>
<div class="paragraph">
<p><code>RewriteCustomizer</code> is similar to <code>RewriteHandler</code> (see <a href="#handler-use-rewrite">this section</a>), but a <code>RewriteCustomizer</code> cannot send a response or otherwise complete the request/response processing.</p>
</div>
<div class="paragraph">
<p>A <code>RewriteCustomizer</code> is mostly useful if you want to rewrite the request URI <em>before</em> the <code>Handler</code> chain is invoked.
However, a very similar effect can be achieved by having the <code>RewriteHandler</code> as the first <code>Handler</code> (the child <code>Handler</code> of the <code>Server</code> instance).</p>
</div>
<div class="paragraph">
<p>Since <code>RewriteCustomizer</code> cannot send a response or complete the request/response processing, <code>Rule</code>s that do so such as redirect rules have no effect and are ignored; only <code>Rule</code>s that modify or wrap the <code>Request</code> will have effect and be applied.</p>
</div>
<div class="paragraph">
<p>Due to this limitation, it is often a better choice to use <code>RewriteHandler</code> instead of <code>RewriteCustomizer</code>.</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>RewriteCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/rewrite/RewriteCustomizer.html">the javadocs</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="request-customizer-secure"><a class="anchor" href="#request-customizer-secure"></a><code>SecureRequestCustomizer</code></h3>
<div class="paragraph">
<p><code>SecureRequestCustomizer</code> should be added when Jetty receives requests over a secure <code>Connector</code>.</p>
</div>
<div class="paragraph">
<p><code>SecureRequestCustomizer</code> adds TLS information as request attributes, in particular an instance of <code>EndPoint.SslSessionData</code> that contains information about the negotiated TLS cipher suite and possibly client certificates, and an instance of <code>org.eclipse.jetty.util.ssl.X509</code> that contains information about the server certificate.</p>
</div>
<div class="paragraph">
<p><code>SecureRequestCustomizer</code> also adds, if configured so, the <code>Strict-Transport-Security</code> HTTP response header (for more information about this header, see <a href="https://datatracker.ietf.org/doc/html/rfc6797">its specification</a>).</p>
</div>
<div class="paragraph">
<p>For more information about how to configure <code>SecureRequestCustomizer</code>, see also <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/SecureRequestCustomizer.html">the javadocs</a>.</p>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connector"><a class="anchor" href="#connector"></a>Server Connectors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <code>Connector</code> is the component that handles incoming requests from clients, and works in conjunction with <code>ConnectionFactory</code> instances.</p>
</div>
<div class="paragraph">
<p>The available implementations are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.eclipse.jetty.server.ServerConnector</code>, for TCP/IP sockets.</p>
</li>
<li>
<p><code>org.eclipse.jetty.unixdomain.server.UnixDomainServerConnector</code> for Unix-Domain sockets (requires Java 16 or later).</p>
</li>
<li>
<p><code>org.eclipse.jetty.quic.server.QuicServerConnector</code>, for the low-level QUIC protocol and HTTP/3.</p>
</li>
<li>
<p><code>org.eclipse.jetty.server.MemoryConnector</code>, for memory communication between client and server.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>ServerConnector</code> and <code>UnixDomainServerConnector</code> use a <code>java.nio.channels.ServerSocketChannel</code> to listen to a socket address and to accept socket connections.
<code>QuicServerConnector</code> uses a <code>java.nio.channels.DatagramChannel</code> to listen to incoming UDP packets.
<code>MemoryConnector</code> uses memory for the communication between client and server, avoiding the use of sockets.</p>
</div>
<div class="paragraph">
<p>Since <code>ServerConnector</code> wraps a <code>ServerSocketChannel</code>, it can be configured in a similar way, for example the TCP port to listen to, the IP address to bind to, etc.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The number of acceptor threads.
int acceptors = 1;

// The number of selectors.
int selectors = 1;

// Create a ServerConnector instance.
ServerConnector connector = new ServerConnector(server, acceptors, selectors, new HttpConnectionFactory());

// Configure TCP/IP parameters.

// The port to listen to.
connector.setPort(8080);
// The address to bind to.
connector.setHost("127.0.0.1");

// The TCP accept queue size.
connector.setAcceptQueueSize(128);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>UnixDomainServerConnector</code> also wraps a <code>ServerSocketChannel</code> and can be configured with the Unix-Domain path to listen to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The number of acceptor threads.
int acceptors = 1;

// The number of selectors.
int selectors = 1;

// Create a ServerConnector instance.
UnixDomainServerConnector connector = new UnixDomainServerConnector(server, acceptors, selectors, new HttpConnectionFactory());

// Configure Unix-Domain parameters.

// The Unix-Domain path to listen to.
connector.setUnixDomainPath(Path.of("/tmp/jetty.sock"));

// The TCP accept queue size.
connector.setAcceptQueueSize(128);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use Unix-Domain sockets only when you run your server with Java 16 or later.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>QuicServerConnector</code> wraps a <code>DatagramChannel</code> and can be configured in a similar way, as shown in the example below.
Since the communication via UDP does not require to "accept" connections like TCP does, the number of <a href="#connector-acceptors">acceptors</a> is set to <code>0</code> and there is no API to configure their number.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Configure the SslContextFactory with the keyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

// Create a QuicServerConnector instance.
Path pemWorkDir = Path.of("/path/to/pem/dir");
ServerQuicConfiguration serverQuicConfig = new ServerQuicConfiguration(sslContextFactory, pemWorkDir);
QuicServerConnector connector = new QuicServerConnector(server, serverQuicConfig, new HTTP3ServerConnectionFactory(serverQuicConfig));

// The port to listen to.
connector.setPort(8080);
// The address to bind to.
connector.setHost("127.0.0.1");

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>MemoryConnector</code> uses in-process memory, not sockets, for the communication between client and server, that therefore must be in the same process.</p>
</div>
<div class="paragraph">
<p>Typical usage of <code>MemoryConnector</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Create a MemoryConnector instance that speaks HTTP/1.1.
MemoryConnector connector = new MemoryConnector(server, new HttpConnectionFactory());

server.addConnector(connector);
server.start();

// The code above is the server-side.
// ----
// The code below is the client-side.

HttpClient httpClient = new HttpClient();
httpClient.start();

ContentResponse response = httpClient.newRequest("http://localhost/")
    // Use the memory Transport to communicate with the server-side.
    .transport(new MemoryTransport(connector))
    .send();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="connector-acceptors"><a class="anchor" href="#connector-acceptors"></a>Acceptors</h3>
<div class="paragraph">
<p>The <em>acceptors</em> are threads (typically only one) that compete to accept TCP socket connections.
The connectors for the QUIC or HTTP/3 protocol, based on UDP, have no acceptors.</p>
</div>
<div class="paragraph">
<p>When a TCP connection is accepted, <code>ServerConnector</code> wraps the accepted <code>SocketChannel</code> and passes it to the <a href="../arch/io.html#selector-manager" class="xref page"><code>SelectorManager</code></a>.
Therefore, there is a little moment where the acceptor thread is not accepting new connections because it is busy wrapping the just accepted connection to pass it to the <code>SelectorManager</code>.
Connections that are ready to be accepted but are not accepted yet are queued in a bounded queue (at the OS level) whose capacity can be configured with the <code>acceptQueueSize</code> parameter.</p>
</div>
<div class="paragraph">
<p>If your application must withstand a very high rate of connection opening, configuring more than one acceptor thread may be beneficial: when one acceptor thread accepts one connection, another acceptor thread can take over accepting connections.</p>
</div>
</div>
<div class="sect2">
<h3 id="connector-selectors"><a class="anchor" href="#connector-selectors"></a>Selectors</h3>
<div class="paragraph">
<p>The <em>selectors</em> are components that manage a set of accepted TCP sockets, implemented by <a href="../arch/io.html#selector-manager" class="xref page"><code>ManagedSelector</code></a>.
For QUIC or HTTP/3, there are no accepted TCP sockets, but only one <code>DatagramChannel</code> and therefore there is only one selector.</p>
</div>
<div class="paragraph">
<p>Each selector requires one thread and uses the Java NIO mechanism to efficiently handle a set of registered channels.</p>
</div>
<div class="paragraph">
<p>As a rule of thumb, a single selector can easily manage up to 1000-5000 TCP sockets, although the number may vary greatly depending on the application.</p>
</div>
<div class="paragraph">
<p>For example, web applications for websites tend to use TCP sockets for one or more HTTP requests to retrieve resources and then the TCP socket is idle for most of the time.
In this case a single selector may be able to manage many TCP sockets because chances are that they will be idle most of the time.
On the contrary, web messaging applications or REST applications tend to send many small messages at a very high frequency so that the TCP sockets are rarely idle.
In this case a single selector may be able to manage less TCP sockets because chances are that many of them will be active at the same time, so you may need more than one selector.</p>
</div>
</div>
<div class="sect2">
<h3 id="connector-multiple"><a class="anchor" href="#connector-multiple"></a>Multiple Connectors</h3>
<div class="paragraph">
<p>It is possible to configure more than one <code>Connector</code> per <code>Server</code>.
Typical cases are a <code>ServerConnector</code> for clear-text HTTP, and another <code>ServerConnector</code> for secure HTTP.
Another case could be a publicly exposed <code>ServerConnector</code> for secure HTTP, and an internally exposed <code>UnixDomainServerConnector</code> or <code>MemoryConnector</code> for clear-text HTTP.
Yet another example could be a <code>ServerConnector</code> for clear-text HTTP, a <code>ServerConnector</code> for secure HTTP/2, and an <code>QuicServerConnector</code> for QUIC+HTTP/3.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Create a ServerConnector instance on port 8080.
ServerConnector connector1 = new ServerConnector(server, 1, 1, new HttpConnectionFactory());
connector1.setPort(8080);
server.addConnector(connector1);

// Create another ServerConnector instance on port 9090,
// for example with a different HTTP configuration.
HttpConfiguration httpConfig2 = new HttpConfiguration();
httpConfig2.setHttpCompliance(HttpCompliance.LEGACY);
ServerConnector connector2 = new ServerConnector(server, 1, 1, new HttpConnectionFactory(httpConfig2));
connector2.setPort(9090);
server.addConnector(connector2);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you do not specify the port the connector listens to explicitly, the OS will allocate one randomly when the connector starts.</p>
</div>
<div class="paragraph">
<p>You may need to use the randomly allocated port to configure other components.
One example is to use the randomly allocated port to configure secure redirects (when redirecting from a URI with the <code>http</code> scheme to the <code>https</code> scheme).
Another example is to bind both the HTTP/2 connector and the HTTP/3 connector to the same randomly allocated port.
It is possible that the HTTP/2 connector and the HTTP/3 connector share the same port, because one uses TCP, while the other uses UDP.</p>
</div>
<div class="paragraph">
<p>For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

Server server = new Server();

// The plain HTTP configuration.
HttpConfiguration plainConfig = new HttpConfiguration();

// The secure HTTP configuration.
HttpConfiguration secureConfig = new HttpConfiguration(plainConfig);
secureConfig.addCustomizer(new SecureRequestCustomizer());

// First, create the secure connector for HTTPS and HTTP/2.
HttpConnectionFactory https = new HttpConnectionFactory(secureConfig);
HTTP2ServerConnectionFactory http2 = new HTTP2ServerConnectionFactory(secureConfig);
ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory();
alpn.setDefaultProtocol(https.getProtocol());
ConnectionFactory ssl = new SslConnectionFactory(sslContextFactory, https.getProtocol());
ServerConnector secureConnector = new ServerConnector(server, 1, 1, ssl, alpn, http2, https);
server.addConnector(secureConnector);

// Second, create the plain connector for HTTP.
HttpConnectionFactory http = new HttpConnectionFactory(plainConfig);
ServerConnector plainConnector = new ServerConnector(server, 1, 1, http);
server.addConnector(plainConnector);

// Third, create the connector for HTTP/3.
Path pemWorkDir = Path.of("/path/to/pem/dir");
ServerQuicConfiguration serverQuicConfig = new ServerQuicConfiguration(sslContextFactory, pemWorkDir);
QuicServerConnector http3Connector = new QuicServerConnector(server, serverQuicConfig, new HTTP3ServerConnectionFactory(serverQuicConfig));
server.addConnector(http3Connector);

// Set up a listener so that when the secure connector starts,
// it configures the other connectors that have not started yet.
secureConnector.addEventListener(new NetworkConnector.Listener()
{
    @Override
    public void onOpen(NetworkConnector connector)
    {
        int port = connector.getLocalPort();

        // Configure the plain connector for secure redirects from http to https.
        plainConfig.setSecurePort(port);

        // Configure the HTTP3 connector port to be the same as HTTPS/HTTP2.
        http3Connector.setPort(port);
    }
});

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect2">
<h3 id="connector-protocol"><a class="anchor" href="#connector-protocol"></a>Configuring Protocols</h3>
<div class="paragraph">
<p>A server <code>Connector</code> can be configured with one or more <code>ConnectionFactory</code>s, and this list of <code>ConnectionFactory</code>s represents the protocols that the <code>Connector</code> can understand.
If no <code>ConnectionFactory</code> is specified then <code>HttpConnectionFactory</code> is implicitly configured.</p>
</div>
<div class="paragraph">
<p>For each accepted connection, the server <code>Connector</code> asks a <code>ConnectionFactory</code> to create a <code>Connection</code> object that handles the traffic on that connection, parsing and generating bytes for a specific protocol (see <a href="../arch/io.html" class="xref page">this section</a> for more details about <code>Connection</code> objects).</p>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
You can listen for <code>Connection</code> open and close events as detailed in <a href="../arch/io.html#connection-listener" class="xref page">this section</a>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Secure protocols like secure HTTP/1.1, secure HTTP/2 or HTTP/3 (HTTP/3 is intrinsically secure&#8201;&#8212;&#8201;there is no clear-text HTTP/3) require an <code>SslContextFactory.Server</code> to be configured with a KeyStore.</p>
</div>
<div class="paragraph">
<p>For HTTP/1.1 and HTTP/2, <code>SslContextFactory.Server</code> is used in conjunction with <code>SSLEngine</code>, which drives the TLS handshake that establishes the secure communication.</p>
</div>
<div class="paragraph">
<p>Applications may register a <code>org.eclipse.jetty.io.ssl.SslHandshakeListener</code> to be notified of TLS handshakes success or failure, by adding the <code>SslHandshakeListener</code> as a bean to the <code>Connector</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a SslHandshakeListener.
SslHandshakeListener listener = new SslHandshakeListener()
{
    @Override
    public void handshakeSucceeded(Event event) throws SSLException
    {
        SSLEngine sslEngine = event.getSSLEngine();
        System.getLogger("tls").log(INFO, "TLS handshake successful to %s", sslEngine.getPeerHost());
    }

    @Override
    public void handshakeFailed(Event event, Throwable failure)
    {
        SSLEngine sslEngine = event.getSSLEngine();
        System.getLogger("tls").log(ERROR, "TLS handshake failure to %s", sslEngine.getPeerHost(), failure);
    }
};

Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

// Add the SslHandshakeListener as bean to ServerConnector.
// The listener will be notified of TLS handshakes success and failure.
connector.addBean(listener);</code></pre>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http11"><a class="anchor" href="#connector-protocol-http11"></a>Clear-Text HTTP/1.1</h4>
<div class="paragraph">
<p><code>HttpConnectionFactory</code> creates <code>HttpConnection</code> objects that parse bytes and generate bytes for the HTTP/1.1 protocol.</p>
</div>
<div class="paragraph">
<p>This is how you configure Jetty to support clear-text HTTP/1.1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Configure the HTTP support, for example:
httpConfig.setSendServerVersion(false);

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// Create the ServerConnector.
ServerConnector connector = new ServerConnector(server, http11);
connector.setPort(8080);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http11-tls"><a class="anchor" href="#connector-protocol-http11-tls"></a>Encrypted HTTP/1.1 (https)</h4>
<div class="paragraph">
<p>Supporting encrypted HTTP/1.1 (that is, requests with the <code>https</code> scheme) is supported by configuring an <code>SslContextFactory</code> that has access to the KeyStore containing the private server key and public server certificate, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Add the SecureRequestCustomizer because TLS is used.
httpConfig.addCustomizer(new SecureRequestCustomizer());

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// Configure the SslContextFactory with the keyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

// The ConnectionFactory for TLS.
SslConnectionFactory tls = new SslConnectionFactory(sslContextFactory, http11.getProtocol());

// The ServerConnector instance.
ServerConnector connector = new ServerConnector(server, tls, http11);
connector.setPort(8443);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can customize the SSL/TLS provider as explained in <a href="#connector-protocol-tls-conscrypt">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http2"><a class="anchor" href="#connector-protocol-http2"></a>Clear-Text HTTP/2</h4>
<div class="paragraph">
<p>It is well known that the HTTP ports are <code>80</code> (for clear-text HTTP) and <code>443</code> for encrypted HTTP.
By using those ports, a client had <em>prior knowledge</em> that the server would speak, respectively, the HTTP/1.x protocol and the TLS protocol (and, after decryption, the HTTP/1.x protocol).</p>
</div>
<div class="paragraph">
<p>HTTP/2 was designed to be a smooth transition from HTTP/1.1 for users and as such the HTTP ports were not changed.
However the HTTP/2 protocol is, on the wire, a binary protocol, completely different from HTTP/1.1.
Therefore, with HTTP/2, clients that connect to port <code>80</code> (or to a specific Unix-Domain path) may speak either HTTP/1.1 or HTTP/2, and the server must figure out which version of the HTTP protocol the client is speaking.</p>
</div>
<div class="paragraph">
<p>Jetty can support both HTTP/1.1 and HTTP/2 on the same clear-text port by configuring both the HTTP/1.1 and the HTTP/2 <code>ConnectionFactory</code>s:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for clear-text HTTP/2.
HTTP2CServerConnectionFactory h2c = new HTTP2CServerConnectionFactory(httpConfig);

// The ServerConnector instance.
ServerConnector connector = new ServerConnector(server, http11, h2c);
connector.setPort(8080);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: first HTTP/1.1, then HTTP/2.
This is necessary to support both protocols on the same port: Jetty will start parsing the incoming bytes as HTTP/1.1, but then realize that they are HTTP/2 bytes and will therefore <em>upgrade</em> from HTTP/1.1 to HTTP/2.</p>
</div>
<div class="paragraph">
<p>This configuration is also typical when Jetty is installed in backend servers behind a load balancer that also takes care of offloading TLS.
When Jetty is behind a load balancer, you can always prepend the PROXY protocol as described in <a href="#connector-protocol-proxy-http11">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http2-tls"><a class="anchor" href="#connector-protocol-http2-tls"></a>Encrypted HTTP/2</h4>
<div class="paragraph">
<p>When using encrypted HTTP/2, the unencrypted protocol is negotiated by client and server using an extension to the TLS protocol called ALPN.</p>
</div>
<div class="paragraph">
<p>Jetty supports ALPN and encrypted HTTP/2 with this configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Add the SecureRequestCustomizer because TLS is used.
httpConfig.addCustomizer(new SecureRequestCustomizer());

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for HTTP/2.
HTTP2ServerConnectionFactory h2 = new HTTP2ServerConnectionFactory(httpConfig);

// The ALPN ConnectionFactory.
ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory();
// The default protocol to use in case there is no negotiation.
alpn.setDefaultProtocol(http11.getProtocol());

// Configure the SslContextFactory with the keyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

// The ConnectionFactory for TLS.
SslConnectionFactory tls = new SslConnectionFactory(sslContextFactory, alpn.getProtocol());

// The ServerConnector instance.
ServerConnector connector = new ServerConnector(server, tls, alpn, h2, http11);
connector.setPort(8443);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: TLS, ALPN, HTTP/2, HTTP/1.1.</p>
</div>
<div class="paragraph">
<p>Jetty starts parsing TLS bytes so that it can obtain the ALPN extension.
With the ALPN extension information, Jetty can negotiate a protocol and pick, among the <code>ConnectionFactory</code>s supported by the <code>ServerConnector</code>, the <code>ConnectionFactory</code> correspondent to the negotiated protocol.</p>
</div>
<div class="paragraph">
<p>The fact that the HTTP/2 protocol comes before the HTTP/1.1 protocol indicates that HTTP/2 is the preferred protocol for the server.</p>
</div>
<div class="paragraph">
<p>Note also that the default protocol set in the ALPN <code>ConnectionFactory</code>, which is used in case ALPN is not supported by the client, is HTTP/1.1&#8201;&#8212;&#8201;if the client does not support ALPN is probably an old client so HTTP/1.1 is the safest choice.</p>
</div>
<div class="paragraph">
<p>You can customize the SSL/TLS provider as explained in <a href="#connector-protocol-tls-conscrypt">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http3"><a class="anchor" href="#connector-protocol-http3"></a>HTTP/3</h4>
<div class="paragraph">
<p>The HTTP/3 protocol is layered on top of the <a href="https://datatracker.ietf.org/doc/html/rfc9000">QUIC</a> protocol, which is based on UDP.
This is rather different with respect to HTTP/1 and HTTP/2, that are based on TCP.</p>
</div>
<div class="paragraph">
<p>Jetty only implements the HTTP/3 layer in Java; the QUIC implementation is provided by the <a href="https://github.com/cloudflare/quiche">Quiche</a> native library, that Jetty calls via <a href="https://github.com/java-native-access/jna">JNA</a> (and possibly, in the future, via the <a href="https://openjdk.org/jeps/454">Foreign APIs</a>).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Jetty&#8217;s HTTP/3 support can only be used on the platforms (OS and CPU) supported by the Quiche native library.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>HTTP/3 clients may not know in advance if the server supports QUIC (over UDP), but the server typically supports either HTTP/1 or HTTP/2 (over TCP) on the default HTTP secure port <code>443</code>, and advertises the availability HTTP/3 as an <a href="https://datatracker.ietf.org/doc/html/rfc7838"><em>HTTP alternate service</em></a>, possibly on a different port and/or on a different host.</p>
</div>
<div class="paragraph">
<p>For example, an HTTP/2 response may include the following header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Alt-Svc: h3=":843"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The presence of this header indicates that protocol <code>h3</code> is available on the same host (since no host is defined before the port), but on port <code>843</code> (although it may be the same port <code>443</code>).
The HTTP/3 client may now initiate a QUIC connection on port <code>843</code> and make HTTP/3 requests.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is nowadays common to use the same port <code>443</code> for both HTTP/2 and HTTP/3. This does not cause problems because HTTP/2 listens on the TCP port <code>443</code>, while QUIC listens on the UDP port <code>443</code>.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>It is therefore common for HTTP/3 clients to initiate connections using the HTTP/2 protocol over TCP, and if the server supports HTTP/3 switch to HTTP/3 as indicated by the server.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/plantuml/svg/eNptjTEPgjAQRvf-igu7mFAGQ6KJcXE00dGllhMa4Iq9gn_fqthgdP3eu3fcGOqVUx1clG4qZwcqd7a1DrxTxAEhecHR6ixZXTvbYRAGnBGuVWnvhiq4qpZRiDB7o02vyINuzbMznxJGN6Ir8lwmoBjq7D38lVYfSU6SeBdhsYmHUMD-dDosM3B4G5C9iCRYkz9zuLfEeKZt6xfHURchvk5en-Zx-R2XnziLiH7qMtZZpGn6ADz6ehw=" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>The code necessary to configure HTTP/2 is described in <a href="#connector-protocol-http2-tls">this section</a>.</p>
</div>
<div class="paragraph">
<p>To setup HTTP/3, for example on port <code>843</code>, you need the following code (some of which could be shared with other connectors such as HTTP/2&#8217;s):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

HttpConfiguration httpConfig = new HttpConfiguration();
httpConfig.addCustomizer(new SecureRequestCustomizer());

// Create and configure the HTTP/3 connector.
// It is mandatory to configure the PEM directory.
Path pemWorkDir = Path.of("/path/to/pem/dir");
ServerQuicConfiguration serverQuicConfig = new ServerQuicConfiguration(sslContextFactory, pemWorkDir);
QuicServerConnector connector = new QuicServerConnector(server, serverQuicConfig, new HTTP3ServerConnectionFactory(serverQuicConfig));
connector.setPort(843);

server.addConnector(connector);

server.start();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The use of the Quiche native library requires the private key and public certificate present in the KeyStore to be exported as PEM files for Quiche to use them.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to configure the PEM directory as shown above.</p>
</div>
<div class="paragraph">
<p>The PEM directory must also be adequately protected using file system permissions, because it stores the private key PEM file.
You want to grant as few permissions as possible, typically the equivalent of POSIX <code>rwx</code> only to the user that runs the Jetty process. Using <code>/tmp</code> or any other directory accessible by any user is not a secure choice.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-tls-conscrypt"><a class="anchor" href="#connector-protocol-tls-conscrypt"></a>Using Conscrypt as SSL/TLS Provider</h4>
<div class="paragraph">
<p>If not explicitly configured, the TLS implementation is provided by the JDK you are using at runtime.</p>
</div>
<div class="paragraph">
<p>OpenJDK&#8217;s vendors may replace the default TLS provider with their own, but you can also explicitly configure an alternative TLS provider.</p>
</div>
<div class="paragraph">
<p>The standard TLS provider from OpenJDK is implemented in Java (no native code), and its performance is not optimal, both in CPU usage and memory usage.</p>
</div>
<div class="paragraph">
<p>A faster alternative, implemented natively, is Google&#8217;s <a href="https://github.com/google/conscrypt/">Conscrypt</a>, which is built on <a href="https://boringssl.googlesource.com/boringssl/">BoringSSL</a>, which is Google&#8217;s fork of <a href="https://www.openssl.org/">OpenSSL</a>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
As Conscrypt eventually binds to a native library, there is a higher risk that a bug in Conscrypt or in the native library causes a JVM crash, while the Java implementation will not cause a JVM crash.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use Conscrypt as TLS provider, you must have the Conscrypt jar and the Jetty dependency <code>jetty-alpn-conscrypt-server-12.0.10-SNAPSHOT.jar</code> in the class-path or module-path.</p>
</div>
<div class="paragraph">
<p>Then, you must configure the JDK with the Conscrypt provider, and configure Jetty to use the Conscrypt provider, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">// Configure the JDK with the Conscrypt provider.
Security.addProvider(new OpenSSLProvider());

SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");
// Configure Jetty's SslContextFactory to use Conscrypt.
sslContextFactory.setProvider("Conscrypt");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-proxy-http11"><a class="anchor" href="#connector-protocol-proxy-http11"></a>Jetty Behind a Load Balancer</h4>
<div class="paragraph">
<p>It is often the case that Jetty receives connections from a load balancer configured to distribute the load among many Jetty backend servers.</p>
</div>
<div class="paragraph">
<p>From the Jetty point of view, all the connections arrive from the load balancer, rather than the real clients, but is possible to configure the load balancer to forward the real client IP address and IP port to the backend Jetty server using the <a href="https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt">PROXY protocol</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The PROXY protocol is widely supported by load balancers such as <a href="http://cbonte.github.io/haproxy-dconv/2.2/configuration.html#5.2-send-proxy">HAProxy</a> (via its <code>send-proxy</code> directive), <a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/using-proxy-protocol">Nginx</a>(via its <code>proxy_protocol on</code> directive) and others.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To support this case, Jetty can be configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Configure the HTTP support, for example:
httpConfig.setSendServerVersion(false);

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for the PROXY protocol.
ProxyConnectionFactory proxy = new ProxyConnectionFactory(http11.getProtocol());

// Create the ServerConnector.
ServerConnector connector = new ServerConnector(server, proxy, http11);
connector.setPort(8080);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: first PROXY, then HTTP/1.1.
Note also how the PROXY <code>ConnectionFactory</code> needs to know its <em>next</em> protocol (in this example, HTTP/1.1).</p>
</div>
<div class="paragraph">
<p>Each <code>ConnectionFactory</code> is asked to create a <code>Connection</code> object for each accepted TCP connection; the <code>Connection</code> objects will be chained together to handle the bytes, each for its own protocol.
Therefore the <code>ProxyConnection</code> will handle the PROXY protocol bytes and <code>HttpConnection</code> will handle the HTTP/1.1 bytes producing a request object and response object that will be processed by <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>The load balancer may be configured to communicate with Jetty backend servers via Unix-Domain sockets (requires Java 16 or later).
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight nowrap"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Configure the HTTP support, for example:
httpConfig.setSendServerVersion(false);

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for the PROXY protocol.
ProxyConnectionFactory proxy = new ProxyConnectionFactory(http11.getProtocol());

// Create the ServerConnector.
UnixDomainServerConnector connector = new UnixDomainServerConnector(server, proxy, http11);
connector.setUnixDomainPath(Path.of("/tmp/jetty.sock"));

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the only difference when using Unix-Domain sockets is instantiating <code>UnixDomainServerConnector</code> instead of <code>ServerConnector</code> and configuring the Unix-Domain path instead of the IP port.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="handler"><a class="anchor" href="#handler"></a>Server Handlers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An <code>org.eclipse.jetty.server.Handler</code> is the component that processes incoming HTTP requests and eventually produces HTTP responses.</p>
</div>
<div class="paragraph">
<p><code>Handler</code>s can process the HTTP request themselves, or they can be <code>Handler.Container</code>s that delegate HTTP request processing to one or more contained <code>Handler</code>s.
This allows <code>Handler</code>s to be organized as a tree comprised of:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Leaf <code>Handler</code>s that generate a response, complete the <code>Callback</code>, and return <code>true</code> from the <code>handle(...)</code> method.</p>
</li>
<li>
<p>A <code>Handler.Wrapper</code> can be used to form a chain of <code>Handler</code>s where request, response or callback objects may be wrapped in the <code>handle(...)</code> method before being passed down the chain.</p>
</li>
<li>
<p>A <code>Handler.Sequence</code> that contains a sequence of <code>Handler</code>s, with each <code>Handler</code> being called in sequence until one returns <code>true</code> from its <code>handle(...)</code> method.</p>
</li>
<li>
<p>A specialized <code>Handler.Container</code> that may use properties of the request (for example, the URI, or a header, etc.) to select from one or more contained <code>Handler</code>s to delegate the HTTP request processing to, for example <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/handler/PathMappingsHandler.html"><code>PathMappingsHandler</code></a>.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>A <code>Handler</code> tree is created by composing <code>Handler</code>s together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

GzipHandler gzipHandler = new GzipHandler();
server.setHandler(gzipHandler);

Handler.Sequence sequence = new Handler.Sequence();
gzipHandler.setHandler(sequence);

sequence.addHandler(new App1Handler());
sequence.addHandler(new App2Handler());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 GzipHandler
     Handler.Sequence
         App1Handler
         App2Handler</code></pre>
</div>
</div>
<div class="paragraph">
<p>You should prefer using existing <code>Handler</code>s provided by the Jetty server libraries for managing web application contexts, security, HTTP sessions and Servlet support.
Refer to <a href="#handler-use">this section</a> for more information about how to use the <code>Handler</code>s provided by the Jetty server libraries.</p>
</div>
<div class="paragraph">
<p>You should write your own leaf <code>Handler</code>s to implement your web application logic.
Refer to <a href="#handler-impl">this section</a> for more information about how to write your own <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>A <code>Handler</code> may be declared as non-blocking (by extending <code>Handler.Abstract.NonBlocking</code>) or as blocking (by extending <code>Handler.Abstract</code>), to allow interaction with the <a href="../arch/threads.html" class="xref page">Jetty threading architecture</a> for more efficient thread and CPU utilization during the request/response processing.</p>
</div>
<div class="paragraph">
<p>Container <code>Handler</code>s typically inherit whether they are blocking or non-blocking from their child or children.</p>
</div>
<div class="paragraph">
<p>Furthermore, container <code>Handler</code>s may be declared as dynamic: they allow adding/removing child <code>Handler</code>s after they have been started (see <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Handler.AbstractContainer.html">Handler.AbstractContainer</a> for more information).
Dynamic container <code>Handler</code>s are therefore always blocking, as it is not possible to know if a child <code>Handler</code> added in the future will be blocking or non-blocking.</p>
</div>
<div class="paragraph">
<p>If the <code>Handler</code> tree is not dynamic, then it is possible to create a non-blocking <code>Handler</code> tree, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 RewriteHandler
     GzipHandler
         ContextHandler
             AppHandler extends Handler.Abstract.NonBlocking</code></pre>
</div>
</div>
<div class="paragraph">
<p>When the <code>Handler</code> tree is non-blocking, Jetty may use the <a href="../arch/threads.html#execution-strategy-pc" class="xref page"><code>Produce-Consume</code></a> mode to invoke the <code>Handler</code> tree, therefore avoiding a thread hand-off, and saving the cost of being scheduled on a different CPU with cold caches.</p>
</div>
<div class="paragraph">
<p>The <code>Produce-Consume</code> mode is equivalent to what other servers call "event loop" or "selector thread loop" architectures.</p>
</div>
<div class="paragraph">
<p>This mode has the benefit of reducing OS context switches and CPU cache misses, using fewer threads, and it is overall very efficient.
On the other hand, it requires writing quick, non-blocking code, and partially sequentializes the request/response processing, so that the Nth request in the sequence pays the latency of the processing of the N-1 requests in front of it.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you declare your <code>Handler</code> to be non-blocking by extending <code>Handler.Abstract.NonBlocking</code>, the code you write in <code>handle(...)</code> (and recursively all the code called from there) must truly be non-blocking, and possibly execute quickly.</p>
</div>
<div class="paragraph">
<p>If the code blocks, you risk a server lock-up.
If the code takes a long time to execute, requests from other connections may be delayed.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="sect2">
<h3 id="handler-use"><a class="anchor" href="#handler-use"></a>Jetty Handlers</h3>
<div class="paragraph">
<p>Web applications are the unit of deployment in an HTTP server or Servlet container such as Jetty.</p>
</div>
<div class="paragraph">
<p>Two different web applications are typically deployed on different <em>context path</em>s, where a <em>context path</em> is the initial segment of the URI path.
For example, web application <code>webappA</code> that implements a web user interface for an e-commerce site may be deployed to context path <code>/shop</code>, while web application <code>webappB</code> that implements a REST API for the e-commerce business may be deployed to <code>/api</code>.</p>
</div>
<div class="paragraph">
<p>A client making a request to URI <code>/shop/cart</code> is directed by Jetty to <code>webappA</code>, while a request to URI <code>/api/products</code> is directed to <code>webappB</code>.</p>
</div>
<div class="paragraph">
<p>An alternative way to deploy the two web applications of the example above is to use <em>virtual hosts</em>.
A <em>virtual host</em> is a subdomain of the primary domain that shares the same IP address with the primary domain.
If the e-commerce business primary domain is <code>domain.com</code>, then a virtual host for <code>webappA</code> could be <code>shop.domain.com</code>, while a virtual host for <code>webappB</code> could be <code>api.domain.com</code>.</p>
</div>
<div class="paragraph">
<p>Web application <code>webappA</code> can now be deployed to virtual host <code>shop.domain.com</code> and context path <code>/</code>, while web application <code>webappB</code> can be deployed to virtual host <code>api.domain.com</code> and context path <code>/</code>.
Both applications have the same context path <code>/</code>, but they can be distinguished by the subdomain.</p>
</div>
<div class="paragraph">
<p>A client making a request to <code>https://shop.domain.com/cart</code> is directed by Jetty to <code>webappA</code>, while a request to <code>https://api.domain.com/products</code> is directed to <code>webappB</code>.</p>
</div>
<div class="paragraph">
<p>Therefore, in general, a web application is deployed to a <em>context</em> which can be seen as the pair <code>(virtual_host, context_path)</code>.
In the first case the contexts were <code>(domain.com, /shop)</code> and <code>(domain.com, /api)</code>, while in the second case the contexts were <code>(shop.domain.com, /)</code> and <code>(api.domain.com, /)</code>.
Server applications using the Jetty Server Libraries create and configure a <em>context</em> for each web application.
Many <em>context</em>s can be deployed together to enrich the web application offering&#8201;&#8212;&#8201;for example a catalog context, a shop context, an API context, an administration context, etc.</p>
</div>
<div class="paragraph">
<p>Web applications can be written using exclusively the Servlet APIs, since developers know well the Servlet API and because they guarantee better portability across Servlet container implementations, as described in <a href="#handler-use-servlet">this section</a>.</p>
</div>
<div class="paragraph">
<p>On the other hand, web applications can be written using the Jetty APIs, for better performance, or to be able to  access to Jetty specific APIs, or to use features such as redirection from HTTP to HTTPS, support for <code>gzip</code> content compression, URI rewriting, etc.
The Jetty Server Libraries provides a number of out-of-the-box <code>Handler</code>s that implement the most common functionalities and are described in the next sections.</p>
</div>
<div class="sect3">
<h4 id="handler-use-context"><a class="anchor" href="#handler-use-context"></a>ContextHandler</h4>
<div class="paragraph">
<p><code>ContextHandler</code> is a <code>Handler</code> that represents a <em>context</em> for a web application.
It is a <code>Handler.Wrapper</code> that performs some action before and after delegating to the nested <code>Handler</code>.</p>
</div>
<div class="paragraph">
<p>The simplest use of <code>ContextHandler</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ShopHandler extends Handler.Abstract
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Implement the shop, remembering to complete the callback.
        return true;
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a ContextHandler with contextPath.
ContextHandler context = new ContextHandler(new ShopHandler(), "/shop");

// Link the context to the server.
server.setHandler(context);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ContextHandler /shop
     ShopHandler</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-context-collection"><a class="anchor" href="#handler-use-context-collection"></a>ContextHandlerCollection</h4>
<div class="paragraph">
<p>Server applications may need to deploy to Jetty more than one web application.</p>
</div>
<div class="paragraph">
<p>Recall from the <a href="#handler">introduction</a> that Jetty offers <code>Handler.Collection</code> that contains a sequence of child <code>Handler</code>s.
However, this has no knowledge of the concept of <em>context</em> and just iterates through the sequence of <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>A better choice for multiple web application is <code>ContextHandlerCollection</code>, that matches a <em>context</em> from either its <em>context path</em> or <em>virtual host</em>, without iterating through the <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>If <code>ContextHandlerCollection</code> does not find a match, it just returns <code>false</code> from its <code>handle(...)</code> method.
What happens next depends on the <code>Handler</code> tree structure: other <code>Handler</code>s may be invoked after <code>ContextHandlerCollection</code>, for example <code>DefaultHandler</code> (see <a href="#handler-use-default">this section</a>).
Eventually, if no <code>Handler</code> returns <code>true</code> from their own <code>handle(...)</code> method, then Jetty returns an HTTP <code>404</code> response to the client.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ShopHandler extends Handler.Abstract
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Implement the shop, remembering to complete the callback.
        return true;
    }
}

class RESTHandler extends Handler.Abstract
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Implement the REST APIs, remembering to complete the callback.
        return true;
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();

// Create the context for the shop web application and add it to ContextHandlerCollection.
contextCollection.addHandler(new ContextHandler(new ShopHandler(), "/shop"));

// Link the ContextHandlerCollection to the Server.
server.setHandler(contextCollection);

server.start();

// Create the context for the API web application.
ContextHandler apiContext = new ContextHandler(new RESTHandler(), "/api");
// Web applications can be deployed after the Server is started.
contextCollection.deployHandler(apiContext, Callback.NOOP);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ContextHandlerCollection
     ContextHandler /shop
        ShopHandler
     ContextHandler /api
         RESTHandler</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-resource"><a class="anchor" href="#handler-use-resource"></a>ResourceHandler&#8201;&#8212;&#8201;Static Content</h4>
<div class="paragraph">
<p>Static content such as images or files (HTML, JavaScript, CSS) can be sent by Jetty very efficiently because Jetty can write the content asynchronously, using direct <code>ByteBuffer</code>s to minimize data copy, and using a memory cache for faster access to the data to send.</p>
</div>
<div class="paragraph">
<p>Being able to write content asynchronously means that if the network gets congested (for example, the client reads the content very slowly) and the server stalls the send of the requested data, then Jetty will wait to resume the send <em>without</em> blocking a thread to finish the send.</p>
</div>
<div class="paragraph">
<p><code>ResourceHandler</code> supports the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Welcome files, for example serving <code>/index.html</code> for request URI <code>/</code></p>
</li>
<li>
<p>Precompressed resources, serving a precompressed <code>/document.txt.gz</code> for request URI <code>/document.txt</code></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7233">Range requests</a>, for requests containing the <code>Range</code> header, which allows clients to pause and resume downloads of large files</p>
</li>
<li>
<p>Directory listing, serving a HTML page with the file list of the requested directory</p>
</li>
<li>
<p>Conditional headers, for requests containing the <code>If-Match</code>, <code>If-None-Match</code>, <code>If-Modified-Since</code>, <code>If-Unmodified-Since</code> headers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The number of features supported and the efficiency in sending static content are on the same level as those of common front-end servers used to serve static content such as Nginx or Apache.
Therefore, the traditional architecture where Nginx/Apache was the front-end server used only to send static content and Jetty was the back-end server used only to send dynamic content is somehow obsolete as Jetty can perform efficiently both tasks.
This leads to simpler systems (less components to configure and manage) and more performance (no need to proxy dynamic requests from front-end servers to back-end servers).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is common to use Nginx/Apache as load balancers, or as rewrite/redirect servers.
We typically recommend <a href="https://haproxy.org">HAProxy</a> as load balancer, and Jetty has <a href="#handler-use-rewrite">rewrite/redirect features</a> as well.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is how you configure a <code>ResourceHandler</code> to create a simple file server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and configure a ResourceHandler.
ResourceHandler handler = new ResourceHandler();
// Configure the directory where static resources are located.
handler.setBaseResource(ResourceFactory.of(handler).newResource("/path/to/static/resources/"));
// Configure directory listing.
handler.setDirAllowed(false);
// Configure welcome files.
handler.setWelcomeFiles(List.of("index.html"));
// Configure whether to accept range requests.
handler.setAcceptRanges(true);

// Link the context to the server.
server.setHandler(handler);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to serve static resources from multiple directories:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ResourceHandler handler = new ResourceHandler();

// For multiple directories, use ResourceFactory.combine().
Resource resource = ResourceFactory.combine(
    ResourceFactory.of(handler).newResource("/path/to/static/resources/"),
    ResourceFactory.of(handler).newResource("/another/path/to/static/resources/")
);
handler.setBaseResource(resource);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the resource is not found, <code>ResourceHandler</code> will not return <code>true</code> from the <code>handle(...)</code> method, so what happens next depends on the <code>Handler</code> tree structure.
See also <a href="#handler-use-default">how to use</a> <code>DefaultHandler</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-gzip"><a class="anchor" href="#handler-use-gzip"></a>GzipHandler</h4>
<div class="paragraph">
<p><code>GzipHandler</code> provides supports for automatic decompression of compressed request content and automatic compression of response content.</p>
</div>
<div class="paragraph">
<p><code>GzipHandler</code> is a <code>Handler.Wrapper</code> that inspects the request and, if the request matches the <code>GzipHandler</code> configuration, just installs the required components to eventually perform decompression of the request content or compression of the response content.
The decompression/compression is not performed until the web application reads request content or writes response content.</p>
</div>
<div class="paragraph">
<p><code>GzipHandler</code> can be configured at the server level in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and configure GzipHandler.
GzipHandler gzipHandler = new GzipHandler();
server.setHandler(gzipHandler);
// Only compress response content larger than this.
gzipHandler.setMinGzipSize(1024);
// Do not compress these URI paths.
gzipHandler.setExcludedPaths("/uncompressed");
// Also compress POST responses.
gzipHandler.addIncludedMethods("POST");
// Do not compress these mime types.
gzipHandler.addExcludedMimeTypes("font/ttf");

// Create a ContextHandlerCollection to manage contexts.
ContextHandlerCollection contexts = new ContextHandlerCollection();
gzipHandler.setHandler(contexts);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 GzipHandler
     ContextHandlerCollection
         ContextHandler 1
        : ...
         ContextHandler N</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, in less common cases, you can configure <code>GzipHandler</code> on a per-context basis, for example because you want to configure <code>GzipHandler</code> with different parameters for each context, or because you want only some contexts to have compression support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
// Link the ContextHandlerCollection to the Server.
server.setHandler(contextCollection);

// Create the context for the shop web application wrapped with GzipHandler so only the shop will do gzip.
GzipHandler shopGzipHandler = new GzipHandler(new ContextHandler(new ShopHandler(), "/shop"));

// Add it to ContextHandlerCollection.
contextCollection.addHandler(shopGzipHandler);

// Create the context for the API web application.
ContextHandler apiContext = new ContextHandler(new RESTHandler(), "/api");

// Add it to ContextHandlerCollection.
contextCollection.addHandler(apiContext);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ContextHandlerCollection
     ContextHandlerCollection
         GzipHandler
            ContextHandler /shop
                ShopHandler
         ContextHandler /api
             RESTHandler</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-rewrite"><a class="anchor" href="#handler-use-rewrite"></a>RewriteHandler</h4>
<div class="paragraph">
<p><code>RewriteHandler</code> provides support for URL rewriting, very similarly to <a href="https://httpd.apache.org/docs/current/mod/mod_rewrite.html">Apache&#8217;s mod_rewrite</a> or <a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html">Nginx rewrite module</a>.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-rewrite&lt;/artifactId&gt;
  &lt;version&gt;12.0.10-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RewriteHandler</code> can be configured with a set of <em>rule</em>s; a <em>rule</em> inspects the request and when it matches it performs some change to the request (for example, changes the URI path, adds/removes headers, etc.).</p>
</div>
<div class="paragraph">
<p>The Jetty Server Libraries provide rules for the most common usages, but you can write your own rules by extending the <code>org.eclipse.jetty.rewrite.handler.Rule</code> class.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>jetty-rewrite</code> module <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/rewrite/handler/package-summary.html">javadocs</a> for the complete list of available rules.</p>
</div>
<div class="paragraph">
<p>You typically want to configure <code>RewriteHandler</code> at the server level, although it is possible to configure it on a per-context basis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and link the RewriteHandler to the Server.
RewriteHandler rewriteHandler = new RewriteHandler();
server.setHandler(rewriteHandler);

// Compacts URI paths with double slashes, e.g. /ctx//path/to//resource.
rewriteHandler.addRule(new CompactPathRule());
// Rewrites */products/* to */p/*.
rewriteHandler.addRule(new RewriteRegexRule("/(.*)/product/(.*)", "/$1/p/$2"));
// Redirects permanently to a different URI.
RedirectRegexRule redirectRule = new RedirectRegexRule("/documentation/(.*)", "https://docs.domain.com/$1");
redirectRule.setStatusCode(HttpStatus.MOVED_PERMANENTLY_301);
rewriteHandler.addRule(redirectRule);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
rewriteHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 RewriteHandler
     ContextHandlerCollection
         ContextHandler 1
        : ...
         ContextHandler N</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-sizelimit"><a class="anchor" href="#handler-use-sizelimit"></a>SizeLimitHandler</h4>
<div class="paragraph">
<p><code>SizeLimitHandler</code> tracks the sizes of request content and response content, and fails the request processing with an HTTP status code of <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-413-content-too-large"><code>413 Content Too Large</code></a>.</p>
</div>
<div class="paragraph">
<p>Server applications can set up the <code>SizeLimitHandler</code> before or after handlers that modify the request content or response content such as <a href="#handler-use-gzip"><code>GzipHandler</code></a>.
When <code>SizeLimitHandler</code> is before <code>GzipHandler</code> in the <code>Handler</code> tree, it will limit the compressed content; when it is after, it will limit the uncompressed content.</p>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure look like the following, to limit uncompressed content:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 GzipHandler
     SizeLimitHandler
         ContextHandlerCollection
             ContextHandler 1
            : ...
             ContextHandler N</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-statistics"><a class="anchor" href="#handler-use-statistics"></a>StatisticsHandler</h4>
<div class="paragraph">
<p><code>StatisticsHandler</code> gathers and exposes a number of statistic values related to request processing such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total number of requests</p>
</li>
<li>
<p>Current number of concurrent requests</p>
</li>
<li>
<p>Minimum, maximum, average and standard deviation of request processing times</p>
</li>
<li>
<p>Number of responses grouped by HTTP code (i.e. how many <code>2xx</code> responses, how many <code>3xx</code> responses, etc.)</p>
</li>
<li>
<p>Total response content bytes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Server applications can read these values and use them internally, or expose them via some service, or <a href="../arch/jmx.html" class="xref page">export them to JMX</a>.</p>
</div>
<div class="paragraph">
<p><code>StatisticsHandler</code> can be configured at the server level or at the context level.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and link the StatisticsHandler to the Server.
StatisticsHandler statsHandler = new StatisticsHandler();
server.setHandler(statsHandler);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
statsHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 StatisticsHandler
     ContextHandlerCollection
         ContextHandler 1
        : ...
         ContextHandler N</code></pre>
</div>
</div>
<div class="paragraph">
<p>It is possible to act on those statistics by subclassing <code>StatisticsHandler</code>.
For instance, <code>StatisticsHandler.MinimumDataRateHandler</code> can be used to enforce a minimum read rate and a minimum write rate based of the figures collected by the <code>StatisticsHandler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and link the MinimumDataRateHandler to the Server.
// Create the MinimumDataRateHandler with a minimum read rate of 1KB per second and no minimum write rate.
StatisticsHandler.MinimumDataRateHandler dataRateHandler = new StatisticsHandler.MinimumDataRateHandler(1024L, 0L);
server.setHandler(dataRateHandler);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
dataRateHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-events"><a class="anchor" href="#handler-use-events"></a>EventsHandler</h4>
<div class="paragraph">
<p><code>EventsHandler</code> allows applications to be notified of <a href="#request-processing-events">request processing</a> events.</p>
</div>
<div class="paragraph">
<p><code>EventsHandler</code> must be subclassed, and the relevant <code>onXYZ()</code> methods overridden to capture the request processing events you are interested in.
The request processing events can be used in conjunction with <code>Request</code> APIs that provide the information you may be interested in.</p>
</div>
<div class="paragraph">
<p>For example, if you want to use <code>EventsHandler</code> to record processing times, you can use the request processing events with the following <code>Request</code> APIs:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>Request.getBeginNanoTime()</code>, which returns the earliest possible nanoTime the request was received.</p>
</li>
<li>
<p><code>Request.getHeadersNanoTime()</code>, which returns the nanoTime at which the parsing of the HTTP headers was completed.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Request</code> and <code>Response</code> objects may be inspected during events, but it is recommended to avoid modifying them, for example by adding/removing headers or by reading/writing content, because any modification may interfere with the processing performed by other <code>Handler</code>s.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>EventsHandler</code> emits the following events:</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>beforeHandling</code></dt>
<dd>
<p>Emitted just before <code>EventsHandler</code> invokes the <code>Handler.handle(...)</code> method of the next <code>Handler</code> in the <code>Handler</code> tree.</p>
</dd>
<dt class="hdlist1"><code>afterHandling</code></dt>
<dd>
<p>Emitted just after the invocation to the <code>Handler.handle(...)</code> method of the next <code>Handler</code> in the <code>Handler</code> tree returns, either normally or by throwing.</p>
</dd>
<dt class="hdlist1"><code>requestRead</code></dt>
<dd>
<p>Emitted every time a chunk of content is read from the <code>Request</code>.</p>
</dd>
<dt class="hdlist1"><code>responseBegin</code></dt>
<dd>
<p>Emitted when the response first write happens.</p>
</dd>
<dt class="hdlist1"><code>responseWrite</code></dt>
<dd>
<p>Emitted every time the write of some response content is initiated.</p>
</dd>
<dt class="hdlist1"><code>responseWriteComplete</code></dt>
<dd>
<p>Emitted every time the write of some response content is completed, either successfully or with a failure.</p>
</dd>
<dt class="hdlist1"><code>responseTrailersComplete</code></dt>
<dd>
<p>Emitted when the write of the response trailers is completed.</p>
</dd>
<dt class="hdlist1"><code>complete</code></dt>
<dd>
<p>Emitted when both request and the response have been completely processed.</p>
</dd>
</dl>
</div>
<div class="paragraph">
<p>Your <code>EventsHandler</code> subclass should then be linked in the <code>Handler</code> tree in the relevant position, typically as the outermost <code>Handler</code> after <code>Server</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyEventsHandler extends EventsHandler
{
    @Override
    protected void onBeforeHandling(Request request)
    {
        // The nanoTime at which the request is first received.
        long requestBeginNanoTime = request.getBeginNanoTime();

        // The nanoTime just before invoking the next Handler.
        request.setAttribute("beforeHandlingNanoTime", NanoTime.now());
    }

    @Override
    protected void onComplete(Request request, int status, HttpFields headers, Throwable failure)
    {
        // Retrieve the before handling nanoTime.
        long beforeHandlingNanoTime = (long)request.getAttribute("beforeHandlingNanoTime");

        // Record the request processing time and the status that was sent back to the client.
        long processingTime = NanoTime.millisSince(beforeHandlingNanoTime);
        System.getLogger("trackTime").log(INFO, "processing request %s took %d ms and ended with status code %d", request, processingTime, status);
    }
}

Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

// Link the EventsHandler as the outermost Handler after Server.
MyEventsHandler eventsHandler = new MyEventsHandler();
server.setHandler(eventsHandler);

ContextHandler appHandler = new ContextHandler("/app");
eventsHandler.setHandler(appHandler);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 MyEventsHandler
     ContextHandler /app</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can link the <code>EventsHandler</code> at any point in the <code>Handler</code> tree structure, and even have multiple <code>EventsHandler</code>s to be notified of the request processing events at the different stages of the <code>Handler</code> tree, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 TotalEventsHandler
     SlowHandler
         AppEventsHandler
             ContextHandler /app</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>TotalEventsHandler</code> may record the total times of request processing, from <code>SlowHandler</code> all the way to the <code>ContextHandler</code>.
On the other hand, <code>AppEventsHandler</code> may record both the time it takes for the request to flow from <code>TotalEventsHandler</code> to <code>AppEventsHandler</code>, therefore effectively measuring the processing time due to <code>SlowHandler</code>, and the time it takes to process the request by the <code>ContextHandler</code>.</p>
</div>
<div class="paragraph">
<p>Refer to the <code>EventsHandler</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/handler/EventsHandler.html">javadocs</a> for further information.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-qos"><a class="anchor" href="#handler-use-qos"></a>QoSHandler</h4>
<div class="paragraph">
<p><code>QoSHandler</code> allows web applications to limit the number of concurrent requests, therefore implementing a quality of service (QoS) mechanism for end users.</p>
</div>
<div class="paragraph">
<p>Web applications may need to access resources with limited capacity, for example a relational database accessed through a JDBC connection pool.</p>
</div>
<div class="paragraph">
<p>Consider the case where each HTTP request results in a JDBC query, and the capacity of the database is of 400 queries/s.
Allowing more than 400 HTTP requests/s into the system, for example 500 requests/s, results in 100 requests blocking waiting for a JDBC connection <em>for every second</em>.
It is evident that even a short load spike of few seconds eventually results in consuming all the server threads: some will be processing requests and queries, the remaining will be blocked waiting for a JDBC connection.
When no more threads are available, additional requests will queue up as tasks in the thread pool, consuming more memory and potentially causing a complete server failure.
This situation affects the whole server, so one bad behaving web application may affect other well behaving web applications.
From the end user perspective the quality of service is terrible, because requests will take a lot of time to be served and eventually time out.</p>
</div>
<div class="paragraph">
<p>In cases of load spikes, caused for example by popular events (weather or social events), usage bursts (Black Friday sales), or even denial of service attacks, it is desirable to give priority to certain requests rather than others.
For example, in an e-commerce site requests that lead to the checkout and to the payments should have higher priorities than requests to browse the products.
Another example is to prioritize requests for certain users such as paying users or administrative users.</p>
</div>
<div class="paragraph">
<p><code>QoSHandler</code> allows you to configure the maximum number of concurrent requests; by extending <code>QoSHandler</code> you can prioritize suspended requests for faster processing.</p>
</div>
<div class="paragraph">
<p>A simple example that just limits the number of concurrent requests:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ShopHandler extends Handler.Abstract
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Implement the shop, remembering to complete the callback.
        callback.succeeded();
        return true;
    }
}

int maxThreads = 256;
QueuedThreadPool serverThreads = new QueuedThreadPool(maxThreads);
Server server = new Server(serverThreads);
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and configure QoSHandler.
QoSHandler qosHandler = new QoSHandler();
// Set the max number of concurrent requests,
// for example in relation to the thread pool.
qosHandler.setMaxRequestCount(maxThreads / 2);
// A suspended request may stay suspended for at most 15 seconds.
qosHandler.setMaxSuspend(Duration.ofSeconds(15));
server.setHandler(qosHandler);

// Provide quality of service to the shop
// application by wrapping ShopHandler with QoSHandler.
qosHandler.setHandler(new ShopHandler());

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>This is an example of a <code>QoSHandler</code> subclass where you can implement a custom prioritization logic:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class PriorityQoSHandler extends QoSHandler
{
    @Override
    protected int getPriority(Request request)
    {
        String pathInContext = Request.getPathInContext(request);

        // Payment requests have the highest priority.
        if (pathInContext.startsWith("/payment/"))
            return 3;

        // Login, checkout and admin requests.
        if (pathInContext.startsWith("/login/"))
            return 2;
        if (pathInContext.startsWith("/checkout/"))
            return 2;
        if (pathInContext.startsWith("/admin/"))
            return 2;

        // Health-check requests from the load balancer.
        if (pathInContext.equals("/health-check"))
            return 1;

        // Other requests have the lowest priority.
        return 0;
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-secured"><a class="anchor" href="#handler-use-secured"></a>SecuredRedirectHandler&#8201;&#8212;&#8201;Redirect from HTTP to HTTPS</h4>
<div class="paragraph">
<p><code>SecuredRedirectHandler</code> allows to redirect requests made with the <code>http</code> scheme (and therefore to the clear-text port) to the <code>https</code> scheme (and therefore to the encrypted port).</p>
</div>
<div class="paragraph">
<p>For example a request to <code>http://domain.com:8080/path?param=value</code> is redirected to <code>https://domain.com:8443/path?param=value</code>.</p>
</div>
<div class="paragraph">
<p>Server applications must configure a <code>HttpConfiguration</code> object with the secure scheme and secure port so that <code>SecuredRedirectHandler</code> can build the redirect URI.</p>
</div>
<div class="paragraph">
<p><code>SecuredRedirectHandler</code> is typically configured at the server level, although it can be configured on a per-context basis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Configure the HttpConfiguration for the clear-text connector.
int securePort = 8443;
HttpConfiguration httpConfig = new HttpConfiguration();
httpConfig.setSecurePort(securePort);

// The clear-text connector.
ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(httpConfig));
connector.setPort(8080);
server.addConnector(connector);

// Configure the HttpConfiguration for the secure connector.
HttpConfiguration httpsConfig = new HttpConfiguration(httpConfig);
// Add the SecureRequestCustomizer because TLS is used.
httpConfig.addCustomizer(new SecureRequestCustomizer());

// The HttpConnectionFactory for the secure connector.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpsConfig);

// Configure the SslContextFactory with the keyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

// The ConnectionFactory for TLS.
SslConnectionFactory tls = new SslConnectionFactory(sslContextFactory, http11.getProtocol());

// The secure connector.
ServerConnector secureConnector = new ServerConnector(server, tls, http11);
secureConnector.setPort(8443);
server.addConnector(secureConnector);

// Create and link the SecuredRedirectHandler to the Server.
SecuredRedirectHandler securedHandler = new SecuredRedirectHandler();
server.setHandler(securedHandler);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
securedHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-cross-origin"><a class="anchor" href="#handler-use-cross-origin"></a>CrossOriginHandler</h4>
<div class="paragraph">
<p><code>CrossOriginHandler</code> supports the server-side requirements of the <a href="https://developer.mozilla.org/en-US/docs/Web/HTTP/CORS">CORS protocol</a> implemented by browsers when performing cross-origin requests.</p>
</div>
<div class="paragraph">
<p>An example of a cross-origin request is when a script downloaded from the origin domain <code>http://domain.com</code> uses <code>fetch()</code> or <code>XMLHttpRequest</code> to make a request to a cross domain such as <code>http://cross.domain.com</code> (a subdomain of the origin domain) or to <code>http://example.com</code> (a completely different domain).</p>
</div>
<div class="paragraph">
<p>This is common, for example, when you embed reusable components such as a chat component into a web page: the web page and the chat component files are downloaded from <code>http://domain.com</code>, but the chat server is at <code>http://chat.domain.com</code>, so the chat component must make cross-origin requests to the chat server.</p>
</div>
<div class="paragraph">
<p>This kind of setup exposes to <a href="https://owasp.org/www-community/attacks/csrf">cross-site request forgery (CSRF) attacks</a>, and the CORS protocol has been established to protect against this kind of attacks.</p>
</div>
<div class="paragraph">
<p>For security reasons, browsers by default do not allow cross-origin requests, unless the response from the cross domain contains the right CORS headers.</p>
</div>
<div class="paragraph">
<p><code>CrossOriginHandler</code> relieves server-side web applications from handling CORS headers explicitly.
You can set up your <code>Handler</code> tree with the <code>CrossOriginHandler</code>, configure it, and it will take care of the CORS headers separately from your application, where you can concentrate on the business logic.</p>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 CrossOriginHandler
     ContextHandler /app
         AppHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>The most important <code>CrossOriginHandler</code> configuration parameter that must be configured is <code>allowedOrigins</code>, which by default is the empty set, therefore disallowing all origins.</p>
</div>
<div class="paragraph">
<p>You want to restrict requests to your cross domain to only origins you trust.
From the chat example above, the chat server at <code>http://chat.domain.com</code> knows that the chat component is downloaded from the origin server at <code>http://domain.com</code>, so the <code>CrossOriginHandler</code> is configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">CrossOriginHandler crossOriginHandler = new CrossOriginHandler();
// The allowed origins are regex patterns.
crossOriginHandler.setAllowedOriginPatterns(Set.of("http://domain\\.com"));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Browsers send cross-origin requests in two ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Directly, if the cross-origin request meets some simple criteria.</p>
</li>
<li>
<p>By issuing a hidden <em>preflight</em> request before the actual cross-origin request, to verify with the server if it is willing to reply properly to the actual cross-origin request.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both preflight requests and cross-origin requests will be handled by <code>CrossOriginHandler</code>, which will analyze the request and possibly add appropriate CORS response headers.</p>
</div>
<div class="paragraph">
<p>By default, preflight requests are not delivered to the <code>CrossOriginHandler</code> child <code>Handler</code>, but it is possible to configure <code>CrossOriginHandler</code> by setting <code>deliverPreflightRequests=true</code> so that the web application can fine-tune the CORS response headers.</p>
</div>
<div class="paragraph">
<p>Another important <code>CrossOriginHandler</code> configuration parameter is <code>allowCredentials</code>, which controls whether cookies and authentication headers that match the cross-origin request to the cross domain are sent in the cross-origin requests.
By default, <code>allowCredentials=false</code> so that cookies and authentication headers are not sent in cross-origin requests.</p>
</div>
<div class="paragraph">
<p>If the application deployed in the cross domain requires cookies or authentication, then you must set <code>allowCredentials=true</code>, but you also need to restrict the allowed origins only to the ones your trust, otherwise your cross domain application will be vulnerable to CSRF attacks.</p>
</div>
<div class="paragraph">
<p>For more <code>CrossOriginHandler</code> configuration options, refer to the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/handler/CrossOriginHandler.html"><code>CrossOriginHandler</code> javadocs</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-state-tracking"><a class="anchor" href="#handler-use-state-tracking"></a>StateTrackingHandler</h4>
<div class="paragraph">
<p><code>StateTrackingHandler</code> is a <a href="../troubleshooting/index.html" class="xref page">troubleshooting</a> <code>Handler</code> that tracks whether <code>Handler</code>/<code>Request</code>/<code>Response</code> asynchronous APIs are properly used by applications.&lt;/p&gt;</p>
</div>
<div class="paragraph">
<p>Asynchronous APIs are notoriously more difficult to troubleshoot than blocking APIs, and may be subject to restrictions that applications need to respect (a typical case is that they cannot perform blocking operations).</p>
</div>
<div class="paragraph">
<p>For example, a <code>Handler</code> implementation whose <code>handle(...)</code> method returns <code>true</code> <em>must</em> eventually complete the callback passed to <code>handle(...)</code> (for more details on the <code>Handler</code> APIs, see <a href="#handler-impl">this section</a>).</p>
</div>
<div class="paragraph">
<p>When an application forgets to complete the callback passed to <code>handle(...)</code>, the HTTP response may not be sent to the client, but it will be difficult to troubleshoot why the client is not receiving responses.</p>
</div>
<div class="paragraph">
<p><code>StateTrackingHandler</code> helps with this troubleshooting because it tracks the callback passed to <code>handle(...)</code> and emits an event if the callback is not completed within a configurable timeout:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StateTrackingHandler stateTrackingHandler = new StateTrackingHandler();

// Emit an event if the Handler callback is not completed with 5 seconds.
stateTrackingHandler.setHandlerCallbackTimeout(5000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>By default, events are logged at warning level, but it is possible to specify a listener to be notified of the events tracked by <code>StateTrackingHandler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">StateTrackingHandler stateTrackingHandler = new StateTrackingHandler(new StateTrackingHandler.Listener()
{
    @Override
    public void onHandlerCallbackNotCompleted(Request request, StateTrackingHandler.ThreadInfo handlerThreadInfo)
    {
        // Your own event handling logic.
    }
});

// Emit an event if the Handler callback is not completed with 5 seconds.
stateTrackingHandler.setHandlerCallbackTimeout(5000);</code></pre>
</div>
</div>
<div class="paragraph">
<p>Other events tracked by <code>StateTrackingHandler</code> are demand callbacks that block, writes that do not complete their callbacks, or write callbacks that block.
The complete list of events is specified by the <code>StateTrackingHandler.Listener</code> class (<a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/handler/StateTrackingHandler.Listener.html">javadocs</a>).</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-default"><a class="anchor" href="#handler-use-default"></a>DefaultHandler</h4>
<div class="paragraph">
<p><code>DefaultHandler</code> is a terminal <code>Handler</code> that always returns <code>true</code> from its <code>handle(...)</code> method and performs the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Serves the <code>favicon.ico</code> Jetty icon when it is requested</p>
</li>
<li>
<p>Sends a HTTP <code>404</code> response for any other request</p>
</li>
<li>
<p>The HTTP <code>404</code> response content nicely shows a HTML table with all the contexts deployed on the <code>Server</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DefaultHandler</code> is set directly on the server, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
server.setDefaultHandler(new DefaultHandler(false, true));

Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Add a ContextHandlerCollection to manage contexts.
ContextHandlerCollection contexts = new ContextHandlerCollection();

// Link the contexts to the Server.
server.setHandler(contexts);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
   ContextHandlerCollection
      ContextHandler 1
     : ...
      ContextHandler N
   DefaultHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>ContextHandlerCollection</code> will try to match a request to one of the contexts; if the match fails, <code>Server</code> will call the <code>DefaultHandler</code> that will return a HTTP <code>404</code> with an HTML page showing the existing contexts deployed on the <code>Server</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>DefaultHandler</code> just sends a nicer HTTP <code>404</code> response in case of wrong requests from clients.
Jetty will send an HTTP <code>404</code> response anyway if <code>DefaultHandler</code> has not been set.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="handler-use-servlet"><a class="anchor" href="#handler-use-servlet"></a>Servlet API Handlers</h3>
<div class="sect3">
<h4 id="handler-use-servlet-context"><a class="anchor" href="#handler-use-servlet-context"></a>ServletContextHandler</h4>
<div class="paragraph">
<p><code>Handler</code>s are easy to write, but often web applications have already been written using the Servlet APIs, using <code>Servlet</code>s and <code>Filter</code>s.</p>
</div>
<div class="paragraph">
<p><code>ServletContextHandler</code> is a <code>ContextHandler</code> that provides support for the Servlet APIs and implements the behaviors required by the Servlet specification.</p>
</div>
<div class="paragraph">
<p>However, differently from <a href="#handler-use-webapp-context"><code>WebAppContext</code></a>, it does not require web application to be packaged as a <code>*.war</code>, nor it requires a <code>web.xml</code> for configuration.</p>
</div>
<div class="paragraph">
<p>With <code>ServletContextHandler</code> you can just put all your Servlet components in a <code>*.jar</code> and configure each component using the <code>ServletContextHandler</code> APIs, in a way equivalent to what you would write in a <code>web.xml</code>.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates depend on the version of Jakarta EE you want to use, and they are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty.ee{8,9,10}&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-ee{8,9,10}-servlet&lt;/artifactId&gt;
  &lt;version&gt;12.0.10-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>For example, for Jakarta EE 10 the coordinates are: <code>org.eclipse.jetty.ee10:jetty-ee10-servlet:12.0.10-SNAPSHOT</code>.</p>
</div>
<div class="paragraph">
<p>Below you can find an example of how to set up a Jakarta EE 10 <code>ServletContextHandler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public class ShopCartServlet extends HttpServlet
{
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
    {
        // Implement the shop cart functionality.
    }
}</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Add the CrossOriginHandler to protect from CSRF attacks.
CrossOriginHandler crossOriginHandler = new CrossOriginHandler();
crossOriginHandler.setAllowedOriginPatterns(Set.of("http://domain.com"));
crossOriginHandler.setAllowCredentials(true);
server.setHandler(crossOriginHandler);

// Create a ServletContextHandler with contextPath.
ServletContextHandler context = new ServletContextHandler();
context.setContextPath("/shop");
// Link the context to the server.
crossOriginHandler.setHandler(context);

// Add the Servlet implementing the cart functionality to the context.
ServletHolder servletHolder = context.addServlet(ShopCartServlet.class, "/cart/*");
// Configure the Servlet with init-parameters.
servletHolder.setInitParameter("maxItems", "128");

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> and Servlet components tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ServletContextHandler /shop
     <em>ShopCartServlet /cart/*</em>
     <em>CrossOriginFilter /*</em></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the Servlet components (they are not <code>Handler</code>s) are represented in <em>italic</em>.</p>
</div>
<div class="paragraph">
<p>Note also how adding a <code>Servlet</code> or a <code>Filter</code> returns a <em>holder</em> object that can be used to specify additional configuration for that particular <code>Servlet</code> or <code>Filter</code>, for example initialization parameters (equivalent to <code>&lt;init-param&gt;</code> in <code>web.xml</code>).</p>
</div>
<div class="paragraph">
<p>When a request arrives to <code>ServletContextHandler</code> the request URI will be matched against the <code>Filter</code>s and <code>Servlet</code> mappings and only those that match will process the request, as dictated by the Servlet specification.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>ServletContextHandler</code> is a terminal <code>Handler</code>, that is it always returns <code>true</code> from its <code>handle(...)</code> method when invoked.
Server applications must be careful when creating the <code>Handler</code> tree to put <code>ServletContextHandler</code>s as last <code>Handler</code>s in any <code>Handler.Collection</code> or as children of a <code>ContextHandlerCollection</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-webapp-context"><a class="anchor" href="#handler-use-webapp-context"></a>WebAppContext</h4>
<div class="paragraph">
<p><code>WebAppContext</code> is a <code>ServletContextHandler</code> that autoconfigures itself by reading a <code>web.xml</code> Servlet configuration file.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates depend on the version of Jakarta EE you want to use, and they are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty.ee{8,9,10}&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-ee{8,9,10}-webapp&lt;/artifactId&gt;
  &lt;version&gt;12.0.10-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Server applications can specify a <code>*.war</code> file or a directory with the structure of a <code>*.war</code> file to <code>WebAppContext</code> to deploy a standard Servlet web application packaged as a <code>war</code> (as defined by the Servlet specification).</p>
</div>
<div class="paragraph">
<p>Where server applications using <code>ServletContextHandler</code> must manually invoke methods to add <code>Servlet</code>s and <code>Filter</code>s as described in <a href="#handler-use-servlet-context">this section</a>, <code>WebAppContext</code> reads <code>WEB-INF/web.xml</code> to add <code>Servlet</code>s and <code>Filter</code>s, and also enforces a number of restrictions defined by the Servlet specification, in particular related to class loading.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a WebAppContext.
WebAppContext context = new WebAppContext();
// Link the context to the server.
server.setHandler(context);

// Configure the path of the packaged web application (file or directory).
context.setWar("/path/to/webapp.war");
// Configure the contextPath.
context.setContextPath("/app");

server.start();</code></pre>
</div>
</div>
<div id="handler-use-webapp-context-class-loading" class="paragraph">
<div class="title">WebAppContext Class Loading</div>
<p>The Servlet specification requires that a web application class loader must load the web application classes from <code>WEB-INF/classes</code> and <code>WEB_INF/lib</code>.
The web application class loader is special because it behaves differently from typical class loaders: where typical class loaders first delegate to their parent class loader and then try to find the class locally, the web application class loader first tries to find the class locally and then delegates to the parent class loader.
The typical class loading model, parent-first, is <em>inverted</em> for web application class loaders, as they use a child-first model.</p>
</div>
<div class="paragraph">
<p>Furthermore, the Servlet specification requires that web applications cannot load or otherwise access the Servlet container implementation classes, also called <em>server classes</em>.
Web applications receive the HTTP request object as an instance of the <code>jakarta.servlet.http.HttpServletRequest</code> interface, and cannot downcast it to the Jetty specific implementation of that interface to access Jetty specific features&#8201;&#8212;&#8201;this ensures maximum web application portability across Servlet container implementations.</p>
</div>
<div class="paragraph">
<p>Lastly, the Servlet specification requires that other classes, also called <em>system classes</em>, such as <code>jakarta.servlet.http.HttpServletRequest</code> or JDK classes such as <code>java.lang.String</code> or <code>java.sql.Connection</code> cannot be modified by web applications by putting, for example, modified versions of those classes in <code>WEB-INF/classes</code> so that they are loaded first by the web application class loader (instead of the class-path class loader where they are normally loaded from).</p>
</div>
<div class="paragraph">
<p><code>WebAppContext</code> implements this class loader logic using a single class loader, <code>WebAppClassLoader</code>, with filtering capabilities: when it loads a class, it checks whether the class is a <em>system class</em> or a <em>server class</em> and acts according to the Servlet specification.</p>
</div>
<div class="paragraph">
<p>When <code>WebAppClassLoader</code> is asked to load a class, it first tries to find the class locally (since it must use the inverted child-first model); if the class is found, and it is not a <em>system class</em>, the class is loaded; otherwise the class is not found locally.
If the class is not found locally, the parent class loader is asked to load the class; the parent class loader uses the standard parent-first model, so it delegates the class loading to its parent, and so on.
If the class is found, and it is not a <em>server class</em>, the class is loaded; otherwise the class is not found and a <code>ClassNotFoundException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the Servlet specification does not define exactly which classes are <em>system classes</em> and which classes are <em>server classes</em>.
However, Jetty picks good defaults and allows server applications to customize <em>system classes</em> and <em>server classes</em> in <code>WebAppContext</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-default-servlet"><a class="anchor" href="#handler-use-default-servlet"></a>DefaultServlet&#8201;&#8212;&#8201;Static Content for Servlets</h4>
<div class="paragraph">
<p>If you have a <a href="#handler-use-servlet-context">Servlet web application</a>, you may want to use a <code>DefaultServlet</code> instead of <code>ResourceHandler</code>.
The features are similar, but <code>DefaultServlet</code> is more commonly used to serve static files for Servlet web applications.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates depend on the version of Jakarta EE you want to use, and they are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty.ee{8,9,10}&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-ee{8,9,10}-servlet&lt;/artifactId&gt;
  &lt;version&gt;12.0.10-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>Below you can find an example of how to setup <code>DefaultServlet</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a ServletContextHandler with contextPath.
ServletContextHandler context = new ServletContextHandler();
context.setContextPath("/app");

// Add the DefaultServlet to serve static content.
ServletHolder servletHolder = context.addServlet(DefaultServlet.class, "/");
// Configure the DefaultServlet with init-parameters.
servletHolder.setInitParameter("resourceBase", "/path/to/static/resources/");
servletHolder.setAsyncSupported(true);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="handler-impl"><a class="anchor" href="#handler-impl"></a>Implementing Handler</h3>
<div class="paragraph">
<p>The <code>Handler</code> API consist fundamentally of just one method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public boolean handle(Request request, Response response, Callback callback) throws Exception</code></pre>
</div>
</div>
<div class="paragraph">
<p>The code that implements the <code>handle(...)</code> method must respect the following contract:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>It may inspect <code>Request</code> immutable information such as URI and headers, typically to decide whether to return <code>true</code> or <code>false</code> (see below).</p>
</li>
<li>
<p>Returning <code>false</code> means that the implementation will not handle the request, and it <strong>must not</strong> complete the <code>callback</code> parameter, nor read the request content, nor write response content.</p>
</li>
<li>
<p>Returning <code>true</code> means that the implementation will handle the request, and it <strong>must</strong> eventually complete the <code>callback</code> parameter.
The completion of the <code>callback</code> parameter may happen synchronously within the invocation to <code>handle(...)</code>, or at a later time, asynchronously, possibly from another thread.
If the response has not been explicitly written when the <code>callback</code> has been completed, the Jetty implementation will write a <code>200</code> response with no content if the <code>callback</code> has been succeeded, or an error response if the <code>callback</code> has been failed.</p>
</li>
</ul>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Violating the contract above may result in undefined or unexpected behavior, and possibly leak resources.</p>
</div>
<div class="paragraph">
<p>For example, returning <code>true</code> from <code>handle(...)</code>, but not completing the <code>callback</code> parameter may result in the request or the response never be completed, likely causing the client to time out.</p>
</div>
<div class="paragraph">
<p>Similarly, returning <code>false</code> from <code>handle(...)</code> but then either writing the response or completing the <code>callback</code> parameter will likely result in a garbled response be sent to the client, as the implementation will either invoke another <code>Handler</code> (that may write a response) or write a default response.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Applications may wrap the request, the response, or the callback and forward the wrapped request, response and callback to a child <code>Handler</code>.</p>
</div>
<div class="sect3">
<h4 id="handler-impl-hello"><a class="anchor" href="#handler-impl-hello"></a>Hello World <code>Handler</code></h4>
<div class="paragraph">
<p>A simple "Hello World" <code>Handler</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class HelloWorldHandler extends Handler.Abstract.NonBlocking
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        response.setStatus(200);
        response.getHeaders().put(HttpHeader.CONTENT_TYPE, "text/html; charset=UTF-8");

        // Write a Hello World response.
        Content.Sink.write(response, true, """
            &lt;!DOCTYPE html&gt;
            &lt;html&gt;
            &lt;head&gt;
              &lt;title&gt;Jetty Hello World Handler&lt;/title&gt;
            &lt;/head&gt;
            &lt;body&gt;
              &lt;p&gt;Hello World&lt;/p&gt;
            &lt;/body&gt;
            &lt;/html&gt;
            """, callback);
        return true;
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Set the Hello World Handler.
server.setHandler(new HelloWorldHandler());

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a simple <code>Handler</code> can access the request and response main features, such as <a href="#handler-impl-request">reading request headers and content</a>, or <a href="#handler-impl-response">writing response headers and content</a>.</p>
</div>
<div class="paragraph">
<p>Note how <code>HelloWorldHandler</code> extends from <code>Handler.Abstract.NonBlocking</code>.
This is a declaration that <code>HelloWorldHandler</code> does not use blocking APIs (of any kind) to perform its logic, allowing Jetty to apply optimizations (see <a href="#handler">here</a>) that are not applied to <code>Handler</code>s that declare themselves as blocking.</p>
</div>
<div class="paragraph">
<p>If your <code>Handler</code> implementation uses blocking APIs (of any kind), extend from <code>Handler.Abstract</code>.</p>
</div>
<div class="paragraph">
<p>Note how the <code>callback</code> parameter is passed to <code>Content.Sink.write(...)</code>&#8201;&#8212;&#8201;a utility method that eventually calls <code>Response.write(...)</code>, so that when the write completes, also the <code>callback</code> parameter is completed.
Note also that because the <code>callback</code> parameter will eventually be completed, the value returned from <code>handle(...)</code> is <code>true</code>.</p>
</div>
<div class="paragraph">
<p>In this way the <a href="#handler-impl"><code>Handler</code> contract</a> is fully respected: when <code>true</code> is returned, the <code>callback</code> will eventually be completed.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-filter"><a class="anchor" href="#handler-impl-filter"></a>Filtering <code>Handler</code></h4>
<div class="paragraph">
<p>A filtering <code>Handler</code> is a handler that perform some modification to the request or response, and then either forwards the request to another <code>Handler</code> or produces an error response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class FilterHandler extends Handler.Wrapper
{
    public FilterHandler(Handler handler)
    {
        super(handler);
    }

    @Override
    public boolean handle(Request request, Response response, Callback callback) throws Exception
    {
        String path = Request.getPathInContext(request);
        if (path.startsWith("/old_path/"))
        {
            // Rewrite old paths to new paths.
            HttpURI uri = request.getHttpURI();
            String newPath = "/new_path/" + path.substring("/old_path/".length());
            HttpURI newURI = HttpURI.build(uri).path(newPath).asImmutable();

            // Modify the request object by wrapping the HttpURI.
            Request newRequest = Request.serveAs(request, newURI);

            // Forward to the next Handler using the wrapped Request.
            return super.handle(newRequest, response, callback);
        }
        else
        {
            // Forward to the next Handler as-is.
            return super.handle(request, response, callback);
        }
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Link the Handlers in a chain.
server.setHandler(new FilterHandler(new HelloWorldHandler()));

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how a filtering <code>Handler</code> extends from <code>Handler.Wrapper</code> and as such needs another handler to forward the request processing to, and how the two <code>Handler</code>s needs to be linked together to work properly.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-request"><a class="anchor" href="#handler-impl-request"></a>Using the <code>Request</code></h4>
<div class="paragraph">
<p>The <code>Request</code> object can be accessed by web applications to inspect the HTTP request URI, the HTTP request headers and read the HTTP request content.</p>
</div>
<div class="paragraph">
<p>Since the <code>Request</code> object may be wrapped by <a href="#handler-impl-filter">filtering <code>Handler</code>s</a>, the design decision for the <code>Request</code> APIs was to keep the number of virtual methods at a minimum.
This minimizes the effort necessary to write <code>Request</code> wrapper implementations and provides a single source for the data carried by <code>Request</code> objects.</p>
</div>
<div class="paragraph">
<p>To use the <code>Request</code> APIs, you should look up the relevant methods in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Request</code> virtual methods.
For example, <code>Request.getMethod()</code> returns the HTTP method used in the request, such as <code>GET</code>, <code>POST</code>, etc.</p>
</li>
<li>
<p><code>Request</code> <code>static</code> methods.
These are utility methods that provide more convenient access to request features.
For example, the HTTP URI query is a string and can be directly accessed via the non-<code>static</code> method <code>request.getHttpURI().getQuery()</code>; however, the query string typically holds key/value parameters and applications should not have the burden to parse the query string, so the <code>static Request.extractQueryParameters(Request)</code> method is provided.</p>
</li>
<li>
<p>Super class <code>static</code> methods.
Since <code>Request</code> <em>is-a</em> <code>Content.Source</code>, look also for <code>static</code> methods in <code>Content.Source</code> that take a <code>Content.Source</code> as a parameter, so that you can pass the <code>Request</code> object as a parameter.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Below you can find a list of the most common <code>Request</code> features and how to access them.
Refer to the <code>Request</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Request.html">javadocs</a> for the complete list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Request</code> URI</dt>
<dd>
<p>The <code>Request</code> URI is accessed via <code>Request.getHttpURI()</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpURI.html"><code>HttpURI</code></a> APIs.</p>
</dd>
<dt class="hdlist1"><code>Request</code> HTTP headers</dt>
<dd>
<p>The <code>Request</code> HTTP headers are accessed via <code>Request.getHeaders()</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpFields.html"><code>HttpFields</code></a> APIs.</p>
</dd>
<dt class="hdlist1"><code>Request</code> cookies</dt>
<dd>
<p>The <code>Request</code> cookies are accessed via <code>static Request.getCookies(Request)</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCookie.html"><code>HttpCookie</code></a> APIs.</p>
</dd>
<dt class="hdlist1"><code>Request</code> parameters</dt>
<dd>
<p>The <code>Request</code> parameters are accessed via <code>static Request.extractQueryParameters(Request)</code> for those present in the HTTP URI query, and via <code>static Request.getParametersAsync(Request)</code> for both query parameters and request content parameters received via form upload with <code>Content-Type: application/x-www-url-form-encoded</code>, and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/util/Fields.html"><code>Fields</code></a> APIs.
If you are only interested in the request content parameters received via form upload, you can use <code>static FormFields.from(Request)</code>, see also <a href="#handler-impl-request-content">this section</a>.</p>
</dd>
<dt class="hdlist1"><code>Request</code> HTTP session</dt>
<dd>
<p>The <code>Request</code> HTTP session is accessed via <code>Request.getSession(boolean)</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Session.html"><code>Session</code></a> APIs.
For more information about how to set up support for HTTP sessions, see <a href="#session">this section</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-request-content"><a class="anchor" href="#handler-impl-request-content"></a>Reading the <code>Request</code> Content</h4>
<div class="paragraph">
<p>Since <code>Request</code> <em>is-a</em> <code>Content.Source</code>, the <a href="../arch/io.html#content-source" class="xref page">section</a> about reading from <code>Content.Source</code> applies to <code>Request</code> as well.
The <code>static Content.Source</code> utility methods will allow you to read the request content as a string, or as an <code>InputStream</code>, for example.</p>
</div>
<div class="paragraph">
<p>There are two special cases that are specific to HTTP for the request content: form parameters (sent when submitting an HTML form) and multipart form data (sent when submitting an HTML form with file upload).</p>
</div>
<div class="paragraph">
<p>For form parameters, typical of HTML form submissions, you can use the <code>FormFields</code> APIs as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class FormHandler extends Handler.Abstract.NonBlocking
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        String contentType = request.getHeaders().get(HttpHeader.CONTENT_TYPE);
        if (MimeTypes.Type.FORM_ENCODED.is(contentType))
        {
            // Convert the request content into Fields.
            CompletableFuture&lt;Fields&gt; completableFields = FormFields.from(request); <i class="conum" data-value="1"></i><b>(1)</b>

            // When all the request content has arrived, process the fields.
            completableFields.whenComplete((fields, failure) -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            {
                if (failure == null)
                {
                    processFields(fields);
                    // Send a simple 200 response, completing the callback.
                    response.setStatus(HttpStatus.OK_200);
                    callback.succeeded();
                }
                else
                {
                    // Reading the request content failed.
                    // Send an error response, completing the callback.
                    Response.writeError(request, response, callback, failure);
                }
            });

            // The callback will be eventually completed in all cases, return true.
            return true;
        }
        else
        {
            // Send an error response, completing the callback, and returning true.
            Response.writeError(request, response, callback, HttpStatus.BAD_REQUEST_400, "invalid request");
            return true;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the <code>Content-Type</code> is <code>x-www-form-urlencoded</code>, read the request content with <code>FormFields</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When all the request content has arrived, process the <code>Fields</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Handler</code> returns <code>true</code>, so the <code>callback</code> parameter <strong>must</strong> be completed.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to use <code>CompletableFuture</code> APIs that are invoked even when reading the request content failed, such as <code>whenComplete(BiConsumer)</code>, <code>handle(BiFunction)</code>, <code>exceptionally(Function)</code>, etc.</p>
</div>
<div class="paragraph">
<p>Failing to do so may result in the <code>Handler</code> <code>callback</code> parameter to never be completed, causing the request processing to hang forever.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>For multipart form data, typical for HTML form file uploads, you can use the <code>MultiPartFormData.Parser</code> APIs as shown here:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MultiPartFormDataHandler extends Handler.Abstract.NonBlocking
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        String contentType = request.getHeaders().get(HttpHeader.CONTENT_TYPE);
        if (MimeTypes.Type.MULTIPART_FORM_DATA.is(contentType))
        {
            // Extract the multipart boundary.
            String boundary = MultiPart.extractBoundary(contentType);

            // Create and configure the multipart parser.
            MultiPartFormData.Parser parser = new MultiPartFormData.Parser(boundary);
            // By default, uploaded files are stored in this directory, to
            // avoid to read the file content (which can be large) in memory.
            parser.setFilesDirectory(Path.of("/tmp"));
            // Convert the request content into parts.
            CompletableFuture&lt;MultiPartFormData.Parts&gt; completableParts = parser.parse(request); <i class="conum" data-value="1"></i><b>(1)</b>

            // When all the request content has arrived, process the parts.
            completableParts.whenComplete((parts, failure) -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
            {
                if (failure == null)
                {
                    // Use the Parts API to process the parts.
                    processParts(parts);
                    // Send a simple 200 response, completing the callback.
                    response.setStatus(HttpStatus.OK_200);
                    callback.succeeded();
                }
                else
                {
                    // Reading the request content failed.
                    // Send an error response, completing the callback.
                    Response.writeError(request, response, callback, failure);
                }
            });

            // The callback will be eventually completed in all cases, return true.
            return true;
        }
        else
        {
            // Send an error response, completing the callback, and returning true.
            Response.writeError(request, response, callback, HttpStatus.BAD_REQUEST_400, "invalid request");
            return true;
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>If the <code>Content-Type</code> is <code>multipart/form-data</code>, read the request content with <code>MultiPartFormData.Parser</code>.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>When all the request content has arrived, process the <code>MultiPartFormData.Parts</code>.</td>
</tr>
</table>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Handler</code> returns <code>true</code>, so the <code>callback</code> parameter <strong>must</strong> be completed.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to use <code>CompletableFuture</code> APIs that are invoked even when reading the request content failed, such as <code>whenComplete(BiConsumer)</code>, <code>handle(BiFunction)</code>, <code>exceptionally(Function)</code>, etc.</p>
</div>
<div class="paragraph">
<p>Failing to do so may result in the <code>Handler</code> <code>callback</code> parameter to never be completed, causing the request processing to hang forever.</p>
</div>
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-request-listeners"><a class="anchor" href="#handler-impl-request-listeners"></a><code>Request</code> Listeners</h4>
<div class="paragraph">
<p>Application may add listeners to the <code>Request</code> object to be notified of particular events happening during the request/response processing.</p>
</div>
<div class="paragraph">
<p><code>Request.addIdleTimeoutListener(Predicate&lt;TimeoutException&gt;)</code> allows you to add an idle timeout listener, which is invoked when an idle timeout period elapses during the request/response processing, if the idle timeout event is not notified otherwise.</p>
</div>
<div class="paragraph">
<p>When an idle timeout event happens, it is delivered to the application as follows:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>If there is pending demand (via <code>Request.demand(Runnable)</code>), then the demand <code>Runnable</code> is invoked and the application may see the idle timeout failure by reading from the <code>Request</code>, obtaining a <a href="../arch/io.html#content-source" class="xref page">transient failure chunk</a>.</p>
</li>
<li>
<p>If there is a pending response write (via <code>Response.write(boolean, ByteBuffer, Callback)</code>), the response write <code>Callback</code> is failed.</p>
</li>
<li>
<p>If neither of the above, the idle timeout listeners are invoked, in the same order they have been added.
The first idle timeout listener that returns <code>true</code> stops the Jetty implementation from invoking the idle timeout listeners that follow.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The idle timeout listeners are therefore invoked only when the application is really idle, neither trying to read nor trying to write.</p>
</div>
<div class="paragraph">
<p>An idle timeout listener may return <code>true</code> to indicate that the idle timeout should be treated as a fatal failure of the request/response processing; otherwise the listener may return <code>false</code> to indicate that no further handling of the idle timeout is needed from the Jetty implementation.</p>
</div>
<div class="paragraph">
<p>When idle timeout listeners return <code>false</code>, then any subsequent idle timeouts are handled as above.
In the case that the application does not initiate any read or write, then the idle timeout listeners are invoked again after another idle timeout period.</p>
</div>
<div class="paragraph">
<p><code>Request.addFailureListener(Consumer&lt;Throwable&gt;)</code> allows you to add a failure listener, which is invoked when a failure happens during the request/response processing.</p>
</div>
<div class="paragraph">
<p>When a failure happens during the request/response processing, then:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>The pending demand for request content, if any, is invoked; that is, the <code>Runnable</code> passed to <code>Request.demand(Runnable)</code> is invoked.</p>
</li>
<li>
<p>The callback of an outstanding call to <code>Response.write(boolean, ByteBuffer, Callback)</code>, if any, is failed.</p>
</li>
<li>
<p>The failure listeners are invoked, in the same order they have been added.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Failure listeners are invoked also in case of idle timeouts, in the following cases:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>At least one idle timeout listener returned <code>true</code> to indicate to the Jetty implementation to treat the idle timeout as a fatal failure.</p>
</li>
<li>
<p>There are no idle timeout listeners.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Failures reported to a failure listener are always fatal failures; see also <a href="../arch/io.html#content-source" class="xref page">this section</a> about fatal versus transient failures.
This means that it is not possible to read or write from a failure listener: the read returns a fatal failure chunk, and the write will immediately fail the write callback.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Applications are always required to complete the <code>Handler</code> callback, as described <a href="#handler-impl">here</a>.
In case of asynchronous failures, failure listeners are a good place to complete (typically by failing it) the <code>Handler</code> callback.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>Request.addCompletionListener(Consumer&lt;Throwable&gt;)</code> allows you to add a completion listener, which is invoked at the very end of the request/response processing.
This is equivalent to adding an <code>HttpStream</code> wrapper and overriding both <code>HttpStream.succeeded()</code> and <code>HttpStream.failed(Throwable)</code>.</p>
</div>
<div class="paragraph">
<p>Completion listeners are typically (but not only) used to recycle or dispose resources used during the request/response processing, or get a precise timing for when the request/response processing finishes, to be paired with <code>Request.getBeginNanoTime()</code>.</p>
</div>
<div class="paragraph">
<p>Note that while failure listeners are invoked as soon as the failure happens, completion listeners are invoked only at the very end of the request/response processing: after the <code>Callback</code> passed to <code>Handler.handle(Request, Response, Callback)</code> has been completed, all container dispatched threads have returned, and all the response writes have been completed.</p>
</div>
<div class="paragraph">
<p>In case of many completion listeners, they are invoked in the reverse order they have been added.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-response"><a class="anchor" href="#handler-impl-response"></a>Using the <code>Response</code></h4>
<div class="paragraph">
<p>The <code>Response</code> object can be accessed by web applications to set the HTTP response status code, the HTTP response headers and write the HTTP response content.</p>
</div>
<div class="paragraph">
<p>The design of the <code>Response</code> APIs is similar to that of the <code>Request</code> APIs, described in <a href="#handler-impl-request">this section</a>.</p>
</div>
<div class="paragraph">
<p>To use the <code>Response</code> APIs, you should look up the relevant methods in the following order:</p>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p><code>Response</code> virtual methods.
For example, <code>Response.setStatus(int)</code> to set the HTTP response status code.</p>
</li>
<li>
<p><code>Request</code> <code>static</code> methods.
These are utility methods that provide more convenient access to response features.
For example, adding an HTTP cookie could be done by adding a <code>Set-Cookie</code> response header, but it would be extremely error-prone.
The utility method <code>static Response.addCookie(Response, HttpCookie)</code> is provided instead.</p>
</li>
<li>
<p>Super class <code>static</code> methods.
Since <code>Response</code> <em>is-a</em> <code>Content.Sink</code>, look also for <code>static</code> methods in <code>Content.Sink</code> that take a <code>Content.Sink</code> as a parameter, so that you can pass the <code>Response</code> object as a parameter.</p>
</li>
</ol>
</div>
<div class="paragraph">
<p>Below you can find a list of the most common <code>Response</code> features and how to access them.
Refer to the <code>Response</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Response.html">javadocs</a> for the complete list.</p>
</div>
<div class="dlist">
<dl>
<dt class="hdlist1"><code>Response</code> status code</dt>
<dd>
<p>The <code>Response</code> HTTP status code is accessed via <code>Response.getStatus()</code> and <code>Response.setStatus(int)</code>.</p>
</dd>
<dt class="hdlist1"><code>Response</code> HTTP headers</dt>
<dd>
<p>The <code>Response</code> HTTP headers are accessed via <code>Response.getHeaders()</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpFields.Mutable.html"><code>HttpFields.Mutable</code></a> APIs.
The response headers are mutable until the response is <em>committed</em>, as defined in <a href="#handler-impl-response-content">this section</a>.</p>
</dd>
<dt class="hdlist1"><code>Response</code> cookies</dt>
<dd>
<p>The <code>Response</code> cookies are accessed via <code>static Response.addCookie(Response, HttpCookie)</code>, <code>static Response.replaceCookie(Response, HttpCookie)</code> and the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/http/HttpCookie.html"><code>HttpCookie</code></a> APIs.
Since cookies translate to HTTP headers, they can be added/replaces until the response is <em>committed</em>, as defined in <a href="#handler-impl-response-content">this section</a>.</p>
</dd>
</dl>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-response-content"><a class="anchor" href="#handler-impl-response-content"></a>Writing the <code>Response</code> Content</h4>
<div class="paragraph">
<p>Since <code>Response</code> <em>is-a</em> <code>Content.Sink</code>, the <a href="../arch/io.html#content-sink" class="xref page">section</a> about writing to <code>Content.Sink</code> applies to <code>Response</code> as well.
The <code>static Content.Sink</code> utility methods will allow you to write the response content as a string, or as an <code>OutputStream</code>, for example.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
The first call to <code>Response.write(boolean, ByteBuffer, Callback)</code> <em>commits</em> the response.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Committing the response means that the response status code and response headers are sent to the other peer, and therefore cannot be modified anymore.
Trying to modify them may result in an <code>IllegalStateException</code> to be thrown, as it is an application mistake to commit the response and then try to modify the headers.</p>
</div>
<div class="paragraph">
<p>You can explicitly commit the response by performing an empty, non-last write:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class FlushingHandler extends Handler.Abstract.NonBlocking
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Set the response status code.
        response.setStatus(HttpStatus.OK_200);
        // Set the response headers.
        response.getHeaders().put(HttpHeader.CONTENT_TYPE, "text/plain");

        // Commit the response with a "flush" write.
        Callback.Completable.with(flush -&gt; response.write(false, null, flush))
            // When the flush is finished, send the content and complete the callback.
            .whenComplete((ignored, failure) -&gt;
            {
                if (failure == null)
                    response.write(true, UTF_8.encode("HELLO"), callback);
                else
                    callback.failed(failure);
            });

        // Return true because the callback will eventually be completed.
        return true;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock warning">
<table>
<tr>
<td class="icon">
<i class="fa icon-warning" title="Warning"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The <code>Handler</code> returns <code>true</code>, so the <code>callback</code> parameter <strong>must</strong> be completed.</p>
</div>
<div class="paragraph">
<p>It is therefore mandatory to use <code>CompletableFuture</code> APIs that are invoked even when writing the response content failed, such as <code>whenComplete(BiConsumer)</code>, <code>handle(BiFunction)</code>, <code>exceptionally(Function)</code>, etc.</p>
</div>
<div class="paragraph">
<p>Failing to do so may result in the <code>Handler</code> <code>callback</code> parameter to never be completed, causing the request processing to hang forever.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Jetty can perform important optimizations for the HTTP/1.1 protocol if the response content length is known before the response is committed:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ContentLengthHandler extends Handler.Abstract.NonBlocking
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Set the response status code.
        response.setStatus(HttpStatus.OK_200);

        String content = """
            {
              "result": 0,
              "advice": {
                "message": "Jetty Rocks!"
              }
            }
            """;
        // Must count the bytes, not the characters!
        byte[] bytes = content.getBytes(UTF_8);
        long contentLength = bytes.length;

        // Set the response headers before the response is committed.
        HttpFields.Mutable responseHeaders = response.getHeaders();
        // Set the content type.
        responseHeaders.put(HttpHeader.CONTENT_TYPE, "application/json; charset=UTF-8");
        // Set the response content length.
        responseHeaders.put(HttpHeader.CONTENT_LENGTH, contentLength);

        // Commit the response.
        response.write(true, ByteBuffer.wrap(bytes), callback);

        // Return true because the callback will eventually be completed.
        return true;
    }
}</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
Setting the response content length is an <em>optimization</em>; Jetty will work well even without it.
If you set the response content length, however, remember that it must specify the number of <em>bytes</em>, not the number of characters.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-response-interim"><a class="anchor" href="#handler-impl-response-interim"></a>Sending Interim <code>Response</code>s</h4>
<div class="paragraph">
<p>The HTTP protocol (any version) allows applications to write <a href="https://www.rfc-editor.org/rfc/rfc9110#name-status-codes">interim responses</a>.</p>
</div>
<div class="paragraph">
<p>An interim response has a status code in the <code>1xx</code> range (but not <code>101</code>), and an application may write zero or more interim response before the final response.</p>
</div>
<div class="paragraph">
<p>This is an example of writing an interim <code>100 Continue</code> response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class Continue100Handler extends Handler.Wrapper
{
    public Continue100Handler(Handler handler)
    {
        super(handler);
    }

    @Override
    public boolean handle(Request request, Response response, Callback callback) throws Exception
    {
        HttpFields requestHeaders = request.getHeaders();
        if (requestHeaders.contains(HttpHeader.EXPECT, HttpHeaderValue.CONTINUE.asString()))
        {
            // Analyze the request and decide whether to receive the content.
            long contentLength = request.getLength();
            if (contentLength &gt; 0 &amp;&amp; contentLength &lt; 1024)
            {
                // Small request content, ask to send it by
                // sending a 100 Continue interim response.
                CompletableFuture&lt;Void&gt; processing = response.writeInterim(HttpStatus.CONTINUE_100, HttpFields.EMPTY) <i class="conum" data-value="1"></i><b>(1)</b>
                    // Then read the request content into a ByteBuffer.
                    .thenCompose(ignored -&gt; Promise.Completable.&lt;ByteBuffer&gt;with(p -&gt; Content.Source.asByteBuffer(request, p)))
                    // Then store the ByteBuffer somewhere.
                    .thenCompose(byteBuffer -&gt; store(byteBuffer));

                // At the end of the processing, complete
                // the callback with the CompletableFuture,
                // a simple 200 response in case of success,
                // or a 500 response in case of failure.
                callback.completeWith(processing); <i class="conum" data-value="2"></i><b>(2)</b>
                return true;
            }
            else
            {
                // The request content is too large, send an error.
                Response.writeError(request, response, callback, HttpStatus.PAYLOAD_TOO_LARGE_413);
                return true;
            }
        }
        else
        {
            return super.handle(request, response, callback);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>Response.writeInterim(...)</code> to send the interim response.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The completion of the callback must take into account both success and failure.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Note how writing an interim response is as asynchronous operation.
As such you must perform subsequent operations using the <code>CompletableFuture</code> APIs, and remember to complete the <code>Handler</code> <code>callback</code> parameter both in case of success or in case of failure.</p>
</div>
<div class="paragraph">
<p>This is an example of writing an interim <code>103 Early Hints</code> response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class EarlyHints103Handler extends Handler.Wrapper
{
    public EarlyHints103Handler(Handler handler)
    {
        super(handler);
    }

    @Override
    public boolean handle(Request request, Response response, Callback callback) throws Exception
    {
        String pathInContext = Request.getPathInContext(request);

        // Simple logic that assumes that every HTML
        // file has associated the same CSS stylesheet.
        if (pathInContext.endsWith(".html"))
        {
            // Tell the client that a Link is coming
            // sending a 103 Early Hints interim response.
            HttpFields.Mutable interimHeaders = HttpFields.build()
                .put(HttpHeader.LINK, "&lt;/style.css&gt;; rel=preload; as=style");

            response.writeInterim(HttpStatus.EARLY_HINTS_103, interimHeaders) <i class="conum" data-value="1"></i><b>(1)</b>
                .whenComplete((ignored, failure) -&gt; <i class="conum" data-value="2"></i><b>(2)</b>
                {
                    if (failure == null)
                    {
                        try
                        {
                            // Delegate the handling to the child Handler.
                            boolean handled = super.handle(request, response, callback);
                            if (!handled)
                            {
                                // The child Handler did not produce a final response, do it here.
                                Response.writeError(request, response, callback, HttpStatus.NOT_FOUND_404);
                            }
                        }
                        catch (Throwable x)
                        {
                            callback.failed(x);
                        }
                    }
                    else
                    {
                        callback.failed(failure);
                    }
                });

            // This Handler sent an interim response, so this Handler
            // (or its descendants) must produce a final response, so return true.
            return true;
        }
        else
        {
            // Not a request for an HTML page, delegate
            // the handling to the child Handler.
            return super.handle(request, response, callback);
        }
    }
}</code></pre>
</div>
</div>
<div class="colist arabic">
<table>
<tr>
<td><i class="conum" data-value="1"></i><b>1</b></td>
<td>Using <code>Response.writeInterim(...)</code> to send the interim response.</td>
</tr>
<tr>
<td><i class="conum" data-value="2"></i><b>2</b></td>
<td>The completion of the callback must take into account both success and failure.</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>An interim response may or may not have its own HTTP headers (this depends on the interim response status code), and they are typically different from the final response HTTP headers.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="session"><a class="anchor" href="#session"></a>HTTP Session Support</h3>
<div class="paragraph">
<p>Some web applications (but not all of them) have the concept of a <em>user</em>, that is a way to identify a specific client that is interacting with the web application.</p>
</div>
<div class="paragraph">
<p>The HTTP session is a feature offered by servers that allows web applications to maintain a temporary, per-user, storage for user-specific data.</p>
</div>
<div class="paragraph">
<p>The storage can be accessed by the web application across multiple request/response interactions with the client.
This makes the web application stateful, because a computation performed by a previous request may be stored in the HTTP session and used in subsequent requests without the need to perform again the computation.</p>
</div>
<div class="paragraph">
<p>Since not all web applications need support for the HTTP session, Jetty offers this feature optionally.</p>
</div>
<div class="paragraph">
<p>The Maven coordinates for the Jetty HTTP session support are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-session&lt;/artifactId&gt;
  &lt;version&gt;12.0.10-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>The HTTP session support is provided by the <code>org.eclipse.jetty.session.SessionHandler</code>, that must be set up in the <code>Handler</code> tree between a <code>ContextHandler</code> and your <code>Handler</code> implementation:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class MyAppHandler extends Handler.Abstract.NonBlocking
{
    @Override
    public boolean handle(Request request, Response response, Callback callback)
    {
        // Your web application implemented here.

        // You can access the HTTP session.
        Session session = request.getSession(false);

        return true;
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a ContextHandler with contextPath.
ContextHandler contextHandler = new ContextHandler("/myApp");
server.setHandler(contextHandler);

// Create and link the SessionHandler.
SessionHandler sessionHandler = new SessionHandler();
contextHandler.setHandler(sessionHandler);

// Link your web application Handler.
sessionHandler.setHandler(new MyAppHandler());

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ContextHandler /myApp
     SessionHandler
         MyAppHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>With the <code>Handler</code>s set up in this way, you can access the HTTP session from your <code>MyAppHandler</code> using <code>Request.getSession(boolean)</code>, and then use the <a href="https://eclipse.dev/jetty/javadoc/jetty-12/org/eclipse/jetty/server/Session.html"><code>Session</code> APIs</a>.</p>
</div>
<div class="paragraph">
<p>The support provided by Jetty for HTTP sessions is advanced and completely pluggable, providing features such as first-level and second-level caching, eviction, etc.</p>
</div>
<div class="paragraph">
<p>You can configure the HTTP session support from a very simple local in-memory configuration, to a replicated (across nodes in a cluster), persistent (for example over file system, database or <a href="https://memcached.org/">memcached</a>) configuration for the most advanced use cases.
The advanced configuration of Jetty&#8217;s HTTP session support is discussed in more details in <a href="session.html" class="xref page">this section</a>.</p>
</div>
</div>
<div class="sect2">
<h3 id="security"><a class="anchor" href="#security"></a>Securing HTTP Server Applications</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="application"><a class="anchor" href="#application"></a>Writing HTTP Server Applications</h3>
<div class="paragraph">
<p>Writing HTTP applications is typically simple, especially when using blocking APIs.
However, there are subtle cases where it is worth clarifying what a server application should do to obtain the desired results when run by Jetty.</p>
</div>
<div class="sect3">
<h4 id="application-1xx"><a class="anchor" href="#application-1xx"></a>Sending 1xx Responses</h4>
<div class="paragraph">
<p>The <a href="https://tools.ietf.org/html/rfc7231#section-5.1.1">HTTP/1.1 RFC</a> allows for <code>1xx</code> informational responses to be sent before a real content response.
Unfortunately the servlet specification does not provide a way for these to be sent, so Jetty has had to provide non-standard handling of these headers.</p>
</div>
</div>
<div class="sect3">
<h4 id="application-100"><a class="anchor" href="#application-100"></a>100 Continue</h4>
<div class="paragraph">
<p>The <code>100 Continue</code> response should be sent by the server when a client sends a request with an <code>Expect: 100-continue</code> header, as the client will not send the body of the request until the <code>100 Continue</code> response has been sent.</p>
</div>
<div class="paragraph">
<p>The intent of this feature is to allow a server to inspect the headers and to tell the client to not send a request body that might be too large or insufficiently private or otherwise unable to be handled.</p>
</div>
<div class="paragraph">
<p>Jetty achieves this by waiting until the input stream or reader is obtained by the filter/servlet, before sending the <code>100 Continue</code> response.
Thus a filter/servlet may inspect the headers of a request before getting the input stream and send an error response (or redirect etc.) rather than the 100 continues.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class Continue100HttpServlet extends HttpServlet
{
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException
    {
        // Inspect the method and headers.
        boolean isPost = HttpMethod.POST.is(request.getMethod());
        boolean expects100 = HttpHeaderValue.CONTINUE.is(request.getHeader("Expect"));
        long contentLength = request.getContentLengthLong();

        if (isPost &amp;&amp; expects100)
        {
            if (contentLength &gt; 1024 * 1024)
            {
                // Rejects uploads that are too large.
                response.sendError(HttpStatus.PAYLOAD_TOO_LARGE_413);
            }
            else
            {
                // Getting the request InputStream indicates that
                // the application wants to read the request content.
                // Jetty will send the 100 Continue response at this
                // point, and the client will send the request content.
                ServletInputStream input = request.getInputStream();

                // Read and process the request input.
            }
        }
        else
        {
            // Process normal requests.
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jetty-102-processing"><a class="anchor" href="#jetty-102-processing"></a>102 Processing</h4>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc2518">RFC 2518</a> defined the <code>102 Processing</code> status code that can be sent:</p>
</div>
<div class="quoteblock">
<blockquote>
when the server has a reasonable expectation that the request will take significant time to complete.
As guidance, if a method is taking longer than 20 seconds (a reasonable, but arbitrary value) to process the server SHOULD return a <code>102 Processing</code> response.
</blockquote>
<div class="attribution">
&#8212; RFC 2518 section 10.1
</div>
</div>
<div class="paragraph">
<p>However, a later update of RFC 2518, <a href="https://tools.ietf.org/html/rfc4918">RFC 4918</a>, removed the <code>102 Processing</code> status code for <a href="https://tools.ietf.org/html/rfc4918#appendix-F.3">"lack of implementation"</a>.</p>
</div>
<div class="paragraph">
<p>Jetty supports the <code>102 Processing</code> status code.
If a request is received with the <code>Expect: 102-processing</code> header, then a filter/servlet may send a <code>102 Processing</code> response (without terminating further processing) by calling <code>response.sendError(102)</code>.</p>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="index.html">Server Libraries</a></span>
  <span class="next"><a href="http2.html">HTTP/2 Server Library</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <div class="footer-main">
    <figure class="footer-brand">
      <a class="logo" href="https://jetty.org"><img src="../../../../../_/img/jetty-logo.svg" alt="Eclipse Jetty" height="46" width="160"></a>
    </figure>
    <ul class="footer-brand-links">
      <li><a href="../../../../index.html">Docs</a></li>
      <li><a href="../../../../../support.html">Support</a></li>
      <li>Lists: <a href="http://dev.eclipse.org/mhonarc/lists/jetty-users/maillist.html" target="_blank" rel="noopener">users</a> - <a href="http://dev.eclipse.org/mhonarc/lists/jetty-dev/maillist.html" target="_blank" rel="noopener">dev</a></li>
      <li><a href="https://github.com/eclipse/jetty.project" target="_blank" rel="noopener">Source</a></li>
    </ul>
    <p class="footer-brand-follow">
      <a href="https://twitter.com/JettyProject" title="Follow us on X" target="_blank" rel="noopener"><img src="../../../../../_/img/x-logo.svg" alt="X logo" class="logo" width="24"><span class="handle">@JettyProject</span></a>
    </p>
  </div>
  <div class="footer-legal">
    <p>Copyright  2008-2024 Webtide</p>
    <p>The <a href="https://github.com/jetty/jetty.website" target="_blank" rel="noopener">UI for this site</a> is derived from the Antora default UI and is licensed under the MPL-2.0 license. Several icons are imported from <a href="https://primer.style/octicons/" target="_blank" rel="noopener">Octicons</a> and are licensed under the MIT license.</p>
    <p>Eclipse Jetty is a trademarks of the Eclipse Foundation, Inc.</p>
  </div>
  <div class="footer-thanks">
    <p>This project is made possible by Webtide. Additional thanks to the <a href="https://eclipse.org" target="_blank" rel="noopener">Eclipse Foundation</a> for hosting this project.</p>
    <p class="badges">
      <a href="https://webtide.com" title="Development led by Webtide" target="_blank" rel="noopener"><img src="../../../../../_/img/webtide-logo.png" alt="Webtide Logo" width="100"></a>
      <a href="https://jetbrains.com/idea" title="IntelliJ IDEA integration provided by JetBrains" target="_blank" rel="noopener"><img src="../../../../../_/img/jetbrains.svg" alt="Jetbrains Logo" width="24"></a>
    </p>
    <p>Authored in <a href="https://asciidoc.org" target="_blank" rel="noopener">AsciiDoc</a>.<br>Produced by <a href="https://antora.org" target="_blank" rel="noopener">Antora</a> and <a href="https://asciidoctor.org" target="_blank" rel="noopener">Asciidoctor</a>.</p>
  </div>
</footer>
<script id="site-script" src="../../../../../_/js/site.js" data-ui-root-path="../../../../../_"></script>
<script async src="../../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../../.." data-snippet-length="100" data-stylesheet="../../../../../_/css/search.css"></script>
<script async src="../../../../../search-index.js"></script>
  </body>
</html>