<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>HTTP Server Libraries :: Eclipse Jetty</title>
    <link rel="canonical" href="https://jetty.org/docs/jetty/12/programming-guide/server/http.html">
    <link rel="prev" href="compliance.html">
    <link rel="next" href="http2.html">
    <meta name="generator" content="Antora 3.1.7">
    <link rel="stylesheet" href="../../../../../_/css/site.css">
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-VS4ZRD6HVM"></script>
    <script>function gtag(){dataLayer.push(arguments)};window.dataLayer=window.dataLayer||[];gtag('js',new Date());gtag('config','G-VS4ZRD6HVM')</script>
    <link rel="icon" href="../../../../../_/img/favicon.ico" type="image/x-icon"/>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item logo" href="https://jetty.org"><img src="../../../../../_/img/jetty-logo.svg" alt="Eclipse Jetty" width="120"></a>
      <a class="navbar-item" href="https://jetty.org">Eclipse Jetty</a>
      <button class="navbar-burger" aria-controls="topbar-nav" aria-expanded="false" aria-label="Toggle main menu">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <div class="navbar-item search hide-for-print">
          <div id="search-field" class="field">
            <input id="search-input" type="text" placeholder="Search the docs">
          </div>
        </div>
        <a class="navbar-item" href="../../../../index.html">Documentation</a>
        <a class="navbar-item" href="../../../../../support.html">Support</a>
        <!--a class="navbar-item" href="../../../../../community.html">Community</a-->
        <a class="navbar-item" href="../../../../../security.html">Security</a>
        <a class="navbar-item" href="../../../../../download.html">Download</a>
        <div class="navbar-item has-dropdown is-hoverable">
          <a class="navbar-link" href="#">Links</a>
          <div class="navbar-dropdown">
            <a class="navbar-item" href="https://github.com/jetty/jetty.project">Source Code</a>
            <a class="navbar-item" href="https://github.com/jetty/jetty.project/issues">Issues</a>
            <a class="navbar-item" href="../../../../contribution-guide/index.html">Contributing</a>
          </div>
        </div>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="jetty" data-version="10">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <button class="nav-menu-toggle" aria-label="Toggle expand/collapse all" style="display: none"></button>
    <h3 class="title"><a href="../../index.html">Eclipse Jetty</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../operations-guide/index.html">Operations Guide</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/begin/index.html">Getting Started</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/features/index.html">Eclipse Jetty Features</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/howtos/index.html">Eclipse Jetty How-Tos</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/arch/index.html">Architecture Overview</a>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../operations-guide/start/index.html">Jetty Start Mechanism</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../operations-guide/start/start-jpms.html">Starting Jetty using JPMS</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../../operations-guide/modules/index.html">Jetty Modules</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../operations-guide/modules/custom.html">Custom Jetty Modules</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../../operations-guide/modules/standard.html">Standard Modules</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/deploy/index.html">Web Application Deployment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/server/index.html">Jetty Server</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/protocols/index.html">Jetty Connectors and Protocols</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/keystore/index.html">Configuring SSL/TLS KeyStores</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/session/index.html">HTTP Session Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/quickstart/index.html">Faster Web Application Deployment</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/annotations/index.html">Annotations</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jsp/index.html">Java Server Pages</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jstl/index.html">JavaServer Pages Standard Tag Libraries</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jsf-taglibs/index.html">JavaServer Faces TagLibs</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jndi/index.html">JNDI</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jaas/index.html">JAAS</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jaspi/index.html">JASPI</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/jmx/index.html">JMX Monitoring &amp; Management</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/troubleshooting/index.html">Troubleshooting</a>
  </li>
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../../operations-guide/xml/index.html">Jetty XML</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../index.html">Programming Guide</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../client/index.html">Client Libraries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/io-arch.html">I/O Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/http.html">HTTP Client</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/http2.html">HTTP/2 Client Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/http3.html">HTTP/3 Client Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../client/websocket.html">WebSocket Client</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="index.html">Server Libraries</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="compliance.html">Server Compliance Modes</a>
  </li>
  <li class="nav-item is-current-page" data-depth="2">
    <a class="nav-link" href="http.html">HTTP Server Libraries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="http2.html">HTTP/2 Server Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="http3.html">HTTP/3 Server Library</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="session.html">HTTP Session Management</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="websocket.html">WebSocket Server</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="fastcgi.html">FastCGI Server Libraries</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="io-arch.html">Server I/O Architecture</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Maven and Jetty</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../maven-jetty/jetty-maven-helloworld.html">Using Maven</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../maven-jetty/jetty-maven-plugin.html">Using the Jetty Maven Plugin</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../maven-jetty/jetty-jspc-maven-plugin.html">Jetty Jspc Maven Plugin</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Jetty Architecture</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/bean.html">Jetty Component Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/threads.html">Jetty Threading Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/io.html">Jetty I/O Architecture</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/listener.html">Jetty Listeners</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../arch/jmx.html">Jetty JMX Support</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../troubleshooting/index.html">Troubleshooting Jetty</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/logging.html">Logging</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/thread-dump.html">JVM Thread Dump</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/component-dump.html">Jetty Component Tree Dump</a>
  </li>
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../troubleshooting/debugging.html">Debugging</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <span class="nav-text">Migration Guides</span>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../migration/94-to-10.html">Migrating from Jetty 9.4.x to Jetty 10.0.x</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">Eclipse Jetty</span>
    <span class="version">10</span>
  </div>
  <ul class="components">
    <li class="component">
      <div class="title"><a href="../../../../contribution-guide/index.html">Contribution Guide</a></div>
    </li>
    <li class="component is-current">
      <div class="title"><a href="../../../12/index.html">Eclipse Jetty</a></div>
      <ul class="versions">
        <li class="version is-latest">
          <a href="../../../12/index.html">12</a>
        </li>
        <li class="version">
          <a href="../../../11/index.html">11</a>
        </li>
        <li class="version is-current">
          <a href="../../index.html">10</a>
        </li>
      </ul>
    </li>
    </li>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../../../../../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../../index.html">Eclipse Jetty</a></li>
    <li><a href="../index.html">Programming Guide</a></li>
    <li><a href="index.html">Server Libraries</a></li>
    <li><a href="http.html">HTTP Server Libraries</a></li>
  </ul>
</nav>
<div class="page-versions">
  <button class="version-menu-toggle" title="Show other versions of page">10</button>
  <div class="version-menu">
    <a class="version" href="../../../12/programming-guide/server/http.html">12</a>
    <a class="version" href="../../../11/programming-guide/server/http.html">11</a>
    <a class="version is-current" href="http.html">10</a>
  </div>
</div>
<div class="edit-this-page"><a href="https://github.com/jetty/jetty.project/edit/jetty-10.0.x/documentation/jetty/modules/programming-guide/pages/server/http.adoc">Edit this Page</a></div>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Page Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">HTTP Server Libraries</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>Web application development typically involves writing your web applications, packaging them into a web application archive, the <code>*.war</code> file, and then deploy the <code>*.war</code> file into a standalone Servlet Container that you have previously installed.</p>
</div>
<div class="paragraph">
<p>The Eclipse Jetty server libraries allow you to write web applications components using either the Jetty APIs (by writing <a href="#handler">Jetty <code>Handler</code>s</a>) or using the standard <a href="#handler-use-servlet">Servlet APIs</a> (by writing <code>Servlet</code>s and Servlet <code>Filter</code>s).
These components can then be programmatically assembled together, without the need of creating a <code>*.war</code> file, added to a Jetty <code>Server</code> instance that is then started.
This result in your web applications to be available to HTTP clients as if you deployed your <code>*.war</code> files in a standalone Jetty server.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-server&lt;/artifactId&gt;
  &lt;version&gt;10.0.21-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p>An <code>org.eclipse.jetty.server.Server</code> instance is the central component that links together a collection of <code>Connector</code>s and a collection of <code>Handler</code>s, with threads from a <code>ThreadPool</code> doing the work.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/plantuml/svg/eNpNjEEOwjAMBO95hT9QJA68oBeOSPABNzZN1MSu7BS-T1ClqrfdndH6kmVFwwoTxmU23YRGLWrQDMU7YmnBD6uqaEymlbuw8Yl4QtJvlhneWPxMViT677cQPGJhuF56TJkYKteJzfcSs8XCITzZPmwwwCsZIz1USxhVhGNT877vwuENcEeh0n9-7GpJ2w==" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>The components that accept connections from clients are <code>org.eclipse.jetty.server.Connector</code> implementations.</p>
</div>
<div class="paragraph">
<p>When a Jetty server interprets the HTTP protocol (HTTP/1.1, HTTP/2 or HTTP/3), it uses <code>org.eclipse.jetty.server.Handler</code> instances to process incoming requests and eventually produce responses.</p>
</div>
<div class="paragraph">
<p>A <code>Server</code> must be created, configured and started:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create and configure a ThreadPool.
QueuedThreadPool threadPool = new QueuedThreadPool();
threadPool.setName("server");

// Create a Server instance.
Server server = new Server(threadPool);

// Create a ServerConnector to accept connections from clients.
Connector connector = new ServerConnector(server);

// Add the Connector to the Server
server.addConnector(connector);

// Set a simple Handler to handle requests/responses.
server.setHandler(new AbstractHandler()
{
    @Override
    public void handle(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response)
    {
        // Mark the request as handled so that it
        // will not be processed by other handlers.
        jettyRequest.setHandled(true);
    }
});

// Start the Server so it starts accepting connections from clients.
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The example above shows the simplest HTTP/1.1 server; it has no support for HTTP sessions, for HTTP authentication, or for any of the features required by the Servlet specification.</p>
</div>
<div class="paragraph">
<p>All these features are provided by the Jetty Server Libraries, and server applications only need to put the required components together to provide all the required features.</p>
</div>
<div class="paragraph">
<p>The <code>Handler</code>s provided by the Jetty Server Libraries allow writing server applications that have functionalities similar to Apache HTTPD or Nginx (for example: URL redirection, URL rewriting, serving static content, reverse proxying, etc.), as well as generating content dynamically by processing incoming requests.
Read <a href="#handler">this section</a> for further details about <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>If you are interested in writing your server application based on the Servlet APIs, jump to <a href="#handler-use-servlet">this section</a>.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="request-processing"><a class="anchor" href="#request-processing"></a>Request Processing</h2>
<div class="sectionbody">
<div class="paragraph">
<p>The Jetty HTTP request processing is outlined below in the diagram below.
You may want to refer to the <a href="../arch/io.html" class="xref page">Jetty I/O architecture</a> for additional information about the classes mentioned below.</p>
</div>
<div class="paragraph">
<p>Request handing is slightly different for each protocol; in HTTP/2 Jetty takes into account multiplexing, something that is not present in HTTP/1.1.</p>
</div>
<div class="paragraph">
<p>However, the diagram below captures the essence of request handling that is common among all protocols that carry HTTP requests.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/plantuml/svg/eNpdkbFuwzAMRHd9hcZ2yA906GK0yFIgQL6AsRhbiEwalJKif99LYjiSF8G4e3cmpXyJMpPR5E_UXwbTq4ROk5ovRpJhsRSXV2pS0X40nRjAlSsnjxT0N8rgz5QyOwe5xD7OJMX_kNDA4ciJ-6LWeF8SDhrxl1rsVARoVGnkA1nmNr4vZe5GAp4a_ch226IkIbFl5zbz-N3nOob_8MYUHsefW1UQr5nAqHzHlOiU-O3dVU7bdAYD_9XS1Gxyz-WQmu8fiC0CrGpJ-HzDo-RNukXGx6roqGVQz1upgUW5NyzXU7n_P5nASA==" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>First, the Jetty I/O layer emits an event that a socket has data to read.
This event is converted to a call to <code>AbstractConnection.onFillable()</code>, where the <code>Connection</code> first reads from the <code>EndPoint</code> into a <code>ByteBuffer</code>, and then calls a protocol specific parser to parse the bytes in the <code>ByteBuffer</code>.</p>
</div>
<div class="paragraph">
<p>The parser emit events that are protocol specific; the HTTP/2 parser, for example, emits events for each HTTP/2 frame that has been parsed, and similarly does the HTTP/3 parser.
The parser events are then converted to protocol independent events such as <em>"request start"</em>, <em>"request headers"</em>, <em>"request content chunk"</em>, etc.
that in turn are converted into method calls to <code>HttpChannel</code>.</p>
</div>
<div class="paragraph">
<p>When enough of the HTTP request is arrived, the <code>Connection</code> calls <code>HttpChannel.handle()</code> that calls the <code>Handler</code> chain, that eventually calls the server application code.</p>
</div>
<div class="sect2">
<h3 id="channel-events"><a class="anchor" href="#channel-events"></a>HttpChannel Events</h3>
<div class="paragraph">
<p>The central component processing HTTP requests is <code>HttpChannel</code>.
There is a 1-to-1 relationship between an HTTP request/response and an <code>HttpChannel</code>, no matter what is the specific protocol that carries the HTTP request over the network (HTTP/1.1, HTTP/2, HTTP/3 or FastCGI).</p>
</div>
<div class="paragraph">
<p>Advanced server applications may be interested in the progress of the processing of an HTTP request/response by <code>HttpChannel</code>.
A typical case is to know exactly <em>when</em> the HTTP request/response processing is complete, for example to monitor processing times.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
A <code>Handler</code> or a Servlet <code>Filter</code> may not report precisely when an HTTP request/response processing is finished.
A server application may write a small enough content that is aggregated by Jetty for efficiency reasons; the write returns immediately, but nothing has been written to the network yet.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p><code>HttpChannel</code> notifies <code>HttpChannel.Listener</code>s of the progress of the HTTP request/response handling.
Currently, the following events are available:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>requestBegin</code></p>
</li>
<li>
<p><code>beforeDispatch</code></p>
</li>
<li>
<p><code>dispatchFailure</code></p>
</li>
<li>
<p><code>afterDispatch</code></p>
</li>
<li>
<p><code>requestContent</code></p>
</li>
<li>
<p><code>requestContentEnd</code></p>
</li>
<li>
<p><code>requestTrailers</code></p>
</li>
<li>
<p><code>requestEnd</code></p>
</li>
<li>
<p><code>responseBegin</code></p>
</li>
<li>
<p><code>responseCommit</code></p>
</li>
<li>
<p><code>responseContent</code></p>
</li>
<li>
<p><code>responseFailure</code></p>
</li>
<li>
<p><code>responseEnd</code></p>
</li>
<li>
<p><code>complete</code></p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Please refer to the <code>HttpChannel.Listener</code> <a href="https://eclipse.dev/jetty/javadoc/jetty-10/org/eclipse/jetty/server/HttpChannel.Listener.html">javadocs</a> for the complete list of events.</p>
</div>
<div class="paragraph">
<p>Server applications can register <code>HttpChannel.Listener</code> by adding them as <a href="../arch/bean.html" class="xref page">beans</a> to the <code>Connector</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class TimingHttpChannelListener implements HttpChannel.Listener
{
    private final ConcurrentMap&lt;Request, Long&gt; times = new ConcurrentHashMap&lt;&gt;();

    @Override
    public void onRequestBegin(Request request)
    {
        times.put(request, NanoTime.now());
    }

    @Override
    public void onComplete(Request request)
    {
        long begin = times.remove(request);
        long elapsed = NanoTime.since(begin);
        System.getLogger("timing").log(INFO, "Request {0} took {1} ns", request, elapsed);
    }
}

Server server = new Server();

Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Add the HttpChannel.Listener as bean to the connector.
connector.addBean(new TimingHttpChannelListener());

// Set a simple Handler to handle requests/responses.
server.setHandler(new AbstractHandler()
{
    @Override
    public void handle(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response)
    {
        jettyRequest.setHandled(true);
    }
});

server.start();</code></pre>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="request-logging"><a class="anchor" href="#request-logging"></a>Request Logging</h2>
<div class="sectionbody">
<div class="paragraph">
<p>HTTP requests and responses can be logged to provide data that can be later analyzed with other tools.
These tools can provide information such as the most frequently accessed request URIs, the response status codes, the request/response content lengths, geographical information about the clients, etc.</p>
</div>
<div class="paragraph">
<p>The default request/response log line format is the <a href="https://en.wikipedia.org/wiki/Common_Log_Format">NCSA Format</a> extended with referrer data and user-agent data.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Typically, the extended NCSA format is the is enough and it&#8217;s the standard used and understood by most log parsing tools and monitoring tools.</p>
</div>
<div class="paragraph">
<p>To customize the request/response log line format see the <a href="https://eclipse.dev/jetty/javadoc/jetty-10/org/eclipse/jetty/server/CustomRequestLog.html"><code>CustomRequestLog</code> javadocs</a>.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>Request logging can be enabled at the server level, or at the web application context level.</p>
</div>
<div class="paragraph">
<p>The request logging output can be directed to an SLF4J logger named <code>"org.eclipse.jetty.server.RequestLog"</code> at <code>INFO</code> level, and therefore to any logging library implementation of your choice (see also <a href="../troubleshooting/logging.html" class="xref page">this section</a> about logging).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Sets the RequestLog to log to an SLF4J logger named "org.eclipse.jetty.server.RequestLog" at INFO level.
server.setRequestLog(new CustomRequestLog(new Slf4jRequestLogWriter(), CustomRequestLog.EXTENDED_NCSA_FORMAT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, the request logging output can be directed to a daily rolling file of your choice, and the file name must contain <code>yyyy_MM_dd</code> so that rolled over files retain their date:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Use a file name with the pattern 'yyyy_MM_dd' so rolled over files retain their date.
RequestLogWriter logWriter = new RequestLogWriter("/var/log/yyyy_MM_dd.jetty.request.log");
// Retain rolled over files for 2 weeks.
logWriter.setRetainDays(14);
// Log times are in the current time zone.
logWriter.setTimeZone(TimeZone.getDefault().getID());

// Set the RequestLog to log to the given file, rolling over at midnight.
server.setRequestLog(new CustomRequestLog(logWriter, CustomRequestLog.EXTENDED_NCSA_FORMAT));</code></pre>
</div>
</div>
<div class="paragraph">
<p>For maximum flexibility, you can log to multiple <code>RequestLog</code>s using class <code>RequestLog.Collection</code>, for example by logging with different formats or to different outputs.</p>
</div>
<div class="paragraph">
<p>You can use <code>CustomRequestLog</code> with a custom <code>RequestLog.Writer</code> to direct the request logging output to your custom targets (for example, an RDBMS).
You can implement your own <code>RequestLog</code> if you want to have functionalities that are not implemented by <code>CustomRequestLog</code>.</p>
</div>
<div class="paragraph">
<p>Request logging can also be enabled at the web application context level, using <code>RequestLogHandler</code> (see <a href="#handler">this section</a> about how to organize Jetty <code>Handler</code>s) to wrap a web application <code>Handler</code>:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Create a first ServletContextHandler for your main application.
ServletContextHandler mainContext = new ServletContextHandler();
mainContext.setContextPath("/main");

// Create a RequestLogHandler to log requests for your main application.
RequestLogHandler requestLogHandler = new RequestLogHandler();
requestLogHandler.setRequestLog(new CustomRequestLog());
// Wrap the main application with the request log handler.
requestLogHandler.setHandler(mainContext);

// Create a second ServletContextHandler for your other application.
// No request logging for this application.
ServletContextHandler otherContext = new ServletContextHandler();
mainContext.setContextPath("/other");

server.setHandler(new HandlerList(requestLogHandler, otherContext));</code></pre>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="connector"><a class="anchor" href="#connector"></a>Server Connectors</h2>
<div class="sectionbody">
<div class="paragraph">
<p>A <code>Connector</code> is the component that handles incoming requests from clients, and works in conjunction with <code>ConnectionFactory</code> instances.</p>
</div>
<div class="paragraph">
<p>The available implementations are:</p>
</div>
<div class="ulist">
<ul>
<li>
<p><code>org.eclipse.jetty.server.ServerConnector</code>, for TCP/IP sockets.</p>
</li>
<li>
<p><code>org.eclipse.jetty.unixdomain.server.UnixDomainServerConnector</code> for Unix-Domain sockets (requires Java 16 or later).</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Both use a <code>java.nio.channels.ServerSocketChannel</code> to listen to a socket address and to accept socket connections.</p>
</div>
<div class="paragraph">
<p>Since <code>ServerConnector</code> wraps a <code>ServerSocketChannel</code>, it can be configured in a similar way, for example the IP port to listen to, the IP address to bind to, etc.:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The number of acceptor threads.
int acceptors = 1;

// The number of selectors.
int selectors = 1;

// Create a ServerConnector instance.
ServerConnector connector = new ServerConnector(server, acceptors, selectors, new HttpConnectionFactory());

// Configure TCP/IP parameters.

// The port to listen to.
connector.setPort(8080);
// The address to bind to.
connector.setHost("127.0.0.1");

// The TCP accept queue size.
connector.setAcceptQueueSize(128);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Likewise, <code>UnixDomainServerConnector</code> also wraps a <code>ServerSocketChannel</code> and can be configured with the Unix-Domain path to listen to:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The number of acceptor threads.
int acceptors = 1;

// The number of selectors.
int selectors = 1;

// Create a ServerConnector instance.
UnixDomainServerConnector connector = new UnixDomainServerConnector(server, acceptors, selectors, new HttpConnectionFactory());

// Configure Unix-Domain parameters.

// The Unix-Domain path to listen to.
connector.setUnixDomainPath(Path.of("/tmp/jetty.sock"));

// The TCP accept queue size.
connector.setAcceptQueueSize(128);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<div class="paragraph">
<p>You can use Unix-Domain sockets support only when you run your server with Java 16 or later.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>The <em>acceptors</em> are threads (typically only one) that compete to accept socket connections.
When a connection is accepted, <code>ServerConnector</code> wraps the accepted <code>SocketChannel</code> and passes it to the <a href="../arch/io.html#selector-manager" class="xref page"><code>SelectorManager</code></a>.
Therefore, there is a little moment where the acceptor thread is not accepting new connections because it is busy wrapping the just accepted connection to pass it to the <code>SelectorManager</code>.
Connections that are ready to be accepted but are not accepted yet are queued in a bounded queue (at the OS level) whose capacity can be configured with the <code>acceptQueueSize</code> parameter.</p>
</div>
<div class="paragraph">
<p>If your application must withstand a very high rate of connections opened, configuring more than one acceptor thread may be beneficial: when one acceptor thread accepts one connection, another acceptor thread can take over accepting connections.</p>
</div>
<div class="paragraph">
<p>The <em>selectors</em> are components that manage a set of connected sockets, implemented by <a href="../arch/io.html#selector-manager" class="xref page"><code>ManagedSelector</code></a>.
Each selector requires one thread and uses the Java NIO mechanism to efficiently handle a set of connected sockets.
As a rule of thumb, a single selector can easily manage up to 1000-5000 sockets, although the number may vary greatly depending on the application.</p>
</div>
<div class="paragraph">
<p>For example, web site applications tend to use sockets for one or more HTTP requests to retrieve resources and then the socket is idle for most of the time.
In this case a single selector may be able to manage many sockets because chances are that they will be idle most of the time.
On the contrary, web messaging applications tend to send many small messages at a very high frequency so that sockets are rarely idle.
In this case a single selector may be able to manage less sockets because chances are that many of them will be active at the same time.</p>
</div>
<div class="paragraph">
<p>It is possible to configure more than one <code>ServerConnector</code> (each listening on a different port), or more than one <code>UnixDomainServerConnector</code> (each listening on a different path), or <code>ServerConnector</code>s and <code>UnixDomainServerConnector</code>s, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Create a ServerConnector instance on port 8080.
ServerConnector connector1 = new ServerConnector(server, 1, 1, new HttpConnectionFactory());
connector1.setPort(8080);
server.addConnector(connector1);

// Create another ServerConnector instance on port 9090,
// for example with a different HTTP configuration.
HttpConfiguration httpConfig2 = new HttpConfiguration();
httpConfig2.setHttpCompliance(HttpCompliance.LEGACY);
ServerConnector connector2 = new ServerConnector(server, 1, 1, new HttpConnectionFactory(httpConfig2));
connector2.setPort(9090);
server.addConnector(connector2);

server.start();</code></pre>
</div>
</div>
<div class="sect2">
<h3 id="connector-protocol"><a class="anchor" href="#connector-protocol"></a>Configuring Protocols</h3>
<div class="paragraph">
<p>For each accepted socket connection, the server <code>Connector</code> asks a <code>ConnectionFactory</code> to create a <code>Connection</code> object that handles the traffic on that socket connection, parsing and generating bytes for a specific protocol (see <a href="../arch/io.html" class="xref page">this section</a> for more details about <code>Connection</code> objects).</p>
</div>
<div class="paragraph">
<p>A server <code>Connector</code> can be configured with one or more <code>ConnectionFactory</code>s.
If no <code>ConnectionFactory</code> is specified then <code>HttpConnectionFactory</code> is implicitly configured.</p>
</div>
<div class="sect3">
<h4 id="connector-protocol-http11"><a class="anchor" href="#connector-protocol-http11"></a>Clear-Text HTTP/1.1</h4>
<div class="paragraph">
<p><code>HttpConnectionFactory</code> creates <code>HttpConnection</code> objects that parse bytes and generate bytes for the HTTP/1.1 protocol.</p>
</div>
<div class="paragraph">
<p>This is how you configure Jetty to support clear-text HTTP/1.1:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Configure the HTTP support, for example:
httpConfig.setSendServerVersion(false);

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// Create the ServerConnector.
ServerConnector connector = new ServerConnector(server, http11);
connector.setPort(8080);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http11-tls"><a class="anchor" href="#connector-protocol-http11-tls"></a>Encrypted HTTP/1.1 (https)</h4>
<div class="paragraph">
<p>Supporting encrypted HTTP/1.1 (that is, requests with the <code>https</code> scheme) is supported by configuring an <code>SslContextFactory</code> that has access to the KeyStore containing the private server key and public server certificate, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Add the SecureRequestCustomizer because we are using TLS.
httpConfig.addCustomizer(new SecureRequestCustomizer());

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// Configure the SslContextFactory with the keyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

// The ConnectionFactory for TLS.
SslConnectionFactory tls = new SslConnectionFactory(sslContextFactory, http11.getProtocol());

// The ServerConnector instance.
ServerConnector connector = new ServerConnector(server, tls, http11);
connector.setPort(8443);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can customize the SSL/TLS provider as explained in <a href="#connector-protocol-tls-conscrypt">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http2"><a class="anchor" href="#connector-protocol-http2"></a>Clear-Text HTTP/2</h4>
<div class="paragraph">
<p>It is well known that the HTTP ports are <code>80</code> (for clear-text HTTP) and <code>443</code> for encrypted HTTP.
By using those ports, a client had <em>prior knowledge</em> that the server would speak, respectively, the HTTP/1.x protocol and the TLS protocol (and, after decryption, the HTTP/1.x protocol).</p>
</div>
<div class="paragraph">
<p>HTTP/2 was designed to be a smooth transition from HTTP/1.1 for users and as such the HTTP ports were not changed.
However the HTTP/2 protocol is, on the wire, a binary protocol, completely different from HTTP/1.1.
Therefore, with HTTP/2, clients that connect to port <code>80</code> (or to a specific Unix-Domain path) may speak either HTTP/1.1 or HTTP/2, and the server must figure out which version of the HTTP protocol the client is speaking.</p>
</div>
<div class="paragraph">
<p>Jetty can support both HTTP/1.1 and HTTP/2 on the same clear-text port by configuring both the HTTP/1.1 and the HTTP/2 <code>ConnectionFactory</code>s:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for clear-text HTTP/2.
HTTP2CServerConnectionFactory h2c = new HTTP2CServerConnectionFactory(httpConfig);

// The ServerConnector instance.
ServerConnector connector = new ServerConnector(server, http11, h2c);
connector.setPort(8080);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: first HTTP/1.1, then HTTP/2.
This is necessary to support both protocols on the same port: Jetty will start parsing the incoming bytes as HTTP/1.1, but then realize that they are HTTP/2 bytes and will therefore <em>upgrade</em> from HTTP/1.1 to HTTP/2.</p>
</div>
<div class="paragraph">
<p>This configuration is also typical when Jetty is installed in backend servers behind a load balancer that also takes care of offloading TLS.
When Jetty is behind a load balancer, you can always prepend the PROXY protocol as described in <a href="#connector-protocol-proxy-http11">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http2-tls"><a class="anchor" href="#connector-protocol-http2-tls"></a>Encrypted HTTP/2</h4>
<div class="paragraph">
<p>When using encrypted HTTP/2, the unencrypted protocol is negotiated by client and server using an extension to the TLS protocol called ALPN.</p>
</div>
<div class="paragraph">
<p>Jetty supports ALPN and encrypted HTTP/2 with this configuration:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Add the SecureRequestCustomizer because we are using TLS.
httpConfig.addCustomizer(new SecureRequestCustomizer());

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for HTTP/2.
HTTP2ServerConnectionFactory h2 = new HTTP2ServerConnectionFactory(httpConfig);

// The ALPN ConnectionFactory.
ALPNServerConnectionFactory alpn = new ALPNServerConnectionFactory();
// The default protocol to use in case there is no negotiation.
alpn.setDefaultProtocol(http11.getProtocol());

// Configure the SslContextFactory with the keyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

// The ConnectionFactory for TLS.
SslConnectionFactory tls = new SslConnectionFactory(sslContextFactory, alpn.getProtocol());

// The ServerConnector instance.
ServerConnector connector = new ServerConnector(server, tls, alpn, h2, http11);
connector.setPort(8443);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: TLS, ALPN, HTTP/2, HTTP/1.1.</p>
</div>
<div class="paragraph">
<p>Jetty starts parsing TLS bytes so that it can obtain the ALPN extension.
With the ALPN extension information, Jetty can negotiate a protocol and pick, among the <code>ConnectionFactory</code>s supported by the <code>ServerConnector</code>, the <code>ConnectionFactory</code> correspondent to the negotiated protocol.</p>
</div>
<div class="paragraph">
<p>The fact that the HTTP/2 protocol comes before the HTTP/1.1 protocol indicates that HTTP/2 is the preferred protocol for the server.</p>
</div>
<div class="paragraph">
<p>Note also that the default protocol set in the ALPN <code>ConnectionFactory</code>, which is used in case ALPN is not supported by the client, is HTTP/1.1&#8201;&#8212;&#8201;if the client does not support ALPN is probably an old client so HTTP/1.1 is the safest choice.</p>
</div>
<div class="paragraph">
<p>You can customize the SSL/TLS provider as explained in <a href="#connector-protocol-tls-conscrypt">this section</a>.</p>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-http3"><a class="anchor" href="#connector-protocol-http3"></a>HTTP/3</h4>
<div class="paragraph">
<p>HTTP/3 is based on UDP, differently from HTTP/1 and HTTP/2 that are based on TCP.</p>
</div>
<div class="paragraph">
<p>An HTTP/3 client may initiate a connection (using the QUIC protocol via UDP) on the canonical HTTP secure port <code>443</code>, but chances are that the connection may not succeed (for example, the server does not listen for UDP on port <code>443</code>, only listens for TCP).</p>
</div>
<div class="paragraph">
<p>For this reason, HTTP servers typically listen on the canonical HTTP secure port <code>443</code> for HTTP/1 and HTTP/2, and advertise the availability HTTP/3 as an <a href="https://datatracker.ietf.org/doc/html/rfc7838"><em>HTTP alternate service</em></a> on a different port (and possibly a different host).</p>
</div>
<div class="paragraph">
<p>For example, an HTTP/2 response may include the following header:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-none hljs">Alt-Svc: h3=":843"</code></pre>
</div>
</div>
<div class="paragraph">
<p>The presence of this header indicates that protocol <code>h3</code> is available on the same host (since no host is defined before the port), but on port <code>843</code>.
The HTTP/3 client may now initiate a QUIC connection on port <code>843</code> and make HTTP/3 requests.</p>
</div>
<div class="imageblock kroki">
<div class="content">
<img src="https://kroki.io/plantuml/svg/eNptjTEPgjAQRvf-igu7mFAGQ6KJcXE00dGllhMa4Iq9gn_fqthgdP3eu3fcGOqVUx1clG4qZwcqd7a1DrxTxAEhecHR6ixZXTvbYRAGnBGuVWnvhiq4qpZRiDB7o02vyINuzbMznxJGN6Ir8lwmoBjq7D38lVYfSU6SeBdhsYmHUMD-dDosM3B4G5C9iCRYkz9zuLfEeKZt6xfHURchvk5en-Zx-R2XnziLiH7qMtZZpGn6ADz6ehw=" alt="Diagram">
</div>
</div>
<div class="paragraph">
<p>The code necessary to configure HTTP/2 is described in <a href="#connector-protocol-http2-tls">this section</a>.</p>
</div>
<div class="paragraph">
<p>To setup HTTP/3, for example on port <code>843</code>, you need the following code (some of which could be shared with other connectors such as HTTP/2&#8217;s):</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

HttpConfiguration httpConfig = new HttpConfiguration();
httpConfig.addCustomizer(new SecureRequestCustomizer());

// Create and configure the HTTP/3 connector.
HTTP3ServerConnector connector = new HTTP3ServerConnector(server, sslContextFactory, new HTTP3ServerConnectionFactory(httpConfig));
connector.setPort(843);
server.addConnector(connector);

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-tls-conscrypt"><a class="anchor" href="#connector-protocol-tls-conscrypt"></a>Using Conscrypt as SSL/TLS Provider</h4>
<div class="paragraph">
<p>If not explicitly configured, the TLS implementation is provided by the JDK you are using at runtime.</p>
</div>
<div class="paragraph">
<p>OpenJDK&#8217;s vendors may replace the default TLS provider with their own, but you can also explicitly configure an alternative TLS provider.</p>
</div>
<div class="paragraph">
<p>The standard TLS provider from OpenJDK is implemented in Java (no native code), and its performance is not optimal, both in CPU usage and memory usage.</p>
</div>
<div class="paragraph">
<p>A faster alternative, implemented natively, is Google&#8217;s <a href="https://github.com/google/conscrypt/">Conscrypt</a>, which is built on <a href="https://boringssl.googlesource.com/boringssl/">BoringSSL</a>, which is Google&#8217;s fork of <a href="https://www.openssl.org/">OpenSSL</a>.</p>
</div>
<div class="admonitionblock caution">
<table>
<tr>
<td class="icon">
<i class="fa icon-caution" title="Caution"></i>
</td>
<td class="content">
As Conscrypt eventually binds to a native library, there is a higher risk that a bug in Conscrypt or in the native library causes a JVM crash, while the Java implementation will not cause a JVM crash.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To use Conscrypt as TLS provider, you must have the Conscrypt jar and the Jetty dependency <code>jetty-alpn-conscrypt-server-10.0.21-SNAPSHOT.jar</code> in the class-path or module-path.</p>
</div>
<div class="paragraph">
<p>Then, you must configure the JDK with the Conscrypt provider, and configure Jetty to use the Conscrypt provider, in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Configure the JDK with the Conscrypt provider.
Security.addProvider(new OpenSSLProvider());

SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");
// Configure Jetty's SslContextFactory to use Conscrypt.
sslContextFactory.setProvider("Conscrypt");</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="connector-protocol-proxy-http11"><a class="anchor" href="#connector-protocol-proxy-http11"></a>Jetty Behind a Load Balancer</h4>
<div class="paragraph">
<p>It is often the case that Jetty receives connections from a load balancer configured to distribute the load among many Jetty backend servers.</p>
</div>
<div class="paragraph">
<p>From the Jetty point of view, all the connections arrive from the load balancer, rather than the real clients, but is possible to configure the load balancer to forward the real client IP address and IP port to the backend Jetty server using the <a href="https://www.haproxy.org/download/2.1/doc/proxy-protocol.txt">PROXY protocol</a>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
The PROXY protocol is widely supported by load balancers such as <a href="http://cbonte.github.io/haproxy-dconv/2.2/configuration.html#5.2-send-proxy">HAProxy</a> (via its <code>send-proxy</code> directive), <a href="https://docs.nginx.com/nginx/admin-guide/load-balancer/using-proxy-protocol">Nginx</a>(via its <code>proxy_protocol on</code> directive) and others.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>To support this case, Jetty can be configured in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Configure the HTTP support, for example:
httpConfig.setSendServerVersion(false);

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for the PROXY protocol.
ProxyConnectionFactory proxy = new ProxyConnectionFactory(http11.getProtocol());

// Create the ServerConnector.
ServerConnector connector = new ServerConnector(server, proxy, http11);
connector.setPort(8080);

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the <code>ConnectionFactory</code>s passed to <code>ServerConnector</code> are in order: first PROXY, then HTTP/1.1.
Note also how the PROXY <code>ConnectionFactory</code> needs to know its <em>next</em> protocol (in this example, HTTP/1.1).</p>
</div>
<div class="paragraph">
<p>Each <code>ConnectionFactory</code> is asked to create a <code>Connection</code> object for each accepted TCP connection; the <code>Connection</code> objects will be chained together to handle the bytes, each for its own protocol.
Therefore the <code>ProxyConnection</code> will handle the PROXY protocol bytes and <code>HttpConnection</code> will handle the HTTP/1.1 bytes producing a request object and response object that will be processed by <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>The load balancer may be configured to communicate with Jetty backend servers via Unix-Domain sockets (requires Java 16 or later).
For example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// The HTTP configuration object.
HttpConfiguration httpConfig = new HttpConfiguration();
// Configure the HTTP support, for example:
httpConfig.setSendServerVersion(false);

// The ConnectionFactory for HTTP/1.1.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpConfig);

// The ConnectionFactory for the PROXY protocol.
ProxyConnectionFactory proxy = new ProxyConnectionFactory(http11.getProtocol());

// Create the ServerConnector.
UnixDomainServerConnector connector = new UnixDomainServerConnector(server, proxy, http11);
connector.setUnixDomainPath(Path.of("/tmp/jetty.sock"));

server.addConnector(connector);
server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note that the only difference when using Unix-Domain sockets is instantiating <code>UnixDomainServerConnector</code> instead of <code>ServerConnector</code> and configuring the Unix-Domain path instead of the IP port.</p>
</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="handler"><a class="anchor" href="#handler"></a>Server Handlers</h2>
<div class="sectionbody">
<div class="paragraph">
<p>An <code>org.eclipse.jetty.server.Handler</code> is the component that processes incoming HTTP requests and eventually produces HTTP responses.</p>
</div>
<div class="paragraph">
<p><code>Handler</code>s can be organized in different ways:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>in a sequence, where <code>Handler</code>s are invoked one after the other</p>
<div class="ulist">
<ul>
<li>
<p><code>HandlerCollection</code> invokes <em>all</em> <code>Handler</code>s one after the other</p>
</li>
<li>
<p><code>HandlerList</code> invokes <code>Handlers</code>s until one calls <code>Request.setHandled(true)</code> to indicate that the request has been handled and no further <code>Handler</code> should be invoked</p>
</li>
</ul>
</div>
</li>
<li>
<p>nested, where one <code>Handler</code> invokes the next, nested, <code>Handler</code></p>
<div class="ulist">
<ul>
<li>
<p><code>HandlerWrapper</code> implements this behavior</p>
</li>
</ul>
</div>
</li>
</ul>
</div>
<div class="paragraph">
<p>The <code>HandlerCollection</code> behavior (invoking <em>all</em> handlers) is useful when for example the last <code>Handler</code> is a logging <code>Handler</code> that logs the request (that may have been modified by previous handlers).</p>
</div>
<div class="paragraph">
<p>The <code>HandlerList</code> behavior (invoking handlers up to the first that calls <code>Request.setHandled(true)</code>) is useful when each handler processes a different URIs or a different virtual hosts: <code>Handler</code>s are invoked one after the other until one matches the URI or virtual host.</p>
</div>
<div class="paragraph">
<p>The nested behavior is useful to enrich the request with additional services such as HTTP session support (<code>SessionHandler</code>), or with specific behaviors dictated by the Servlet specification (<code>ServletHandler</code>).</p>
</div>
<div class="paragraph">
<p><code>Handler</code>s can be organized in a tree by composing them together:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a Server instance.
Server server = new Server();

HandlerCollection collection = new HandlerCollection();
// Link the root Handler with the Server.
server.setHandler(collection);

HandlerList list = new HandlerList();
collection.addHandler(list);
collection.addHandler(new LoggingHandler());

list.addHandler(new App1Handler());
HandlerWrapper wrapper = new HandlerWrapper();
list.addHandler(wrapper);

wrapper.setHandler(new App2Handler());</code></pre>
</div>
</div>
<div class="paragraph">
<p>The corresponding <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">HandlerCollection
 HandlerList
    App1Handler
    HandlerWrapper
        App2Handler
 LoggingHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>Server applications should rarely write custom <code>Handler</code>s, preferring instead to use existing <code>Handler</code>s provided by the Jetty Server Libraries for managing web application contexts, security, HTTP sessions and Servlet support.
Refer to <a href="#handler-use">this section</a> for more information about how to use the <code>Handler</code>s provided by the Jetty Server Libraries.</p>
</div>
<div class="paragraph">
<p>However, in some cases the additional features are not required, or additional constraints on memory footprint, or performance, or just simplicity must be met.
In these cases, implementing your own <code>Handler</code> may be a better solution.
Refer to <a href="#handler-implement">this section</a> for more information about how to write your own <code>Handler</code>s.</p>
</div>
<div class="sect2">
<h3 id="handler-use"><a class="anchor" href="#handler-use"></a>Jetty Handlers</h3>
<div class="paragraph">
<p>Web applications are the unit of deployment in an HTTP server or Servlet container such as Jetty.</p>
</div>
<div class="paragraph">
<p>Two different web applications are typically deployed on different <em>context path</em>s, where a <em>context path</em> is the initial segment of the URI path.
For example, web application <code>webappA</code> that implements a web user interface for an e-commerce site may be deployed to context path <code>/shop</code>, while web application <code>webappB</code> that implements a REST API for the e-commerce business may be deployed to <code>/api</code>.</p>
</div>
<div class="paragraph">
<p>A client making a request to URI <code>/shop/cart</code> is directed by Jetty to <code>webappA</code>, while a request to URI <code>/api/products</code> is directed to <code>webappB</code>.</p>
</div>
<div class="paragraph">
<p>An alternative way to deploy the two web applications of the example above is to use <em>virtual hosts</em>.
A <em>virtual host</em> is a subdomain of the primary domain that shares the same IP address with the primary domain.
If the e-commerce business primary domain is <code>domain.com</code>, then a virtual host for <code>webappA</code> could be <code>shop.domain.com</code>, while a virtual host for <code>webappB</code> could be <code>api.domain.com</code>.</p>
</div>
<div class="paragraph">
<p>Web application <code>webappA</code> can now be deployed to virtual host <code>shop.domain.com</code> and context path <code>/</code>, while web application <code>webappB</code> can be deployed to virtual host <code>api.domain.com</code> and context path <code>/</code>.
Both applications have the same context path <code>/</code>, but they can be distinguished by the subdomain.</p>
</div>
<div class="paragraph">
<p>A client making a request to <code>https://shop.domain.com/cart</code> is directed by Jetty to <code>webappA</code>, while a request to <code>https://api.domain.com/products</code> is directed to <code>webappB</code>.</p>
</div>
<div class="paragraph">
<p>Therefore, in general, a web application is deployed to a <em>context</em> which can be seen as the pair <code>(virtual_host, context_path)</code>.
In the first case the contexts were <code>(domain.com, /shop)</code> and <code>(domain.com, /api)</code>, while in the second case the contexts were <code>(shop.domain.com, /)</code> and <code>(api.domain.com, /)</code>.
Server applications using the Jetty Server Libraries create and configure a <em>context</em> for each web application.
Many <em>context</em>s can be deployed together to enrich the web application offering&#8201;&#8212;&#8201;for example a catalog context, a shop context, an API context, an administration context, etc.</p>
</div>
<div class="paragraph">
<p>Web applications can be written using exclusively the Servlet APIs, since developers know well the Servlet API and because they guarantee better portability across Servlet container implementations.</p>
</div>
<div class="paragraph">
<p>Embedded web applications based on the Servlet APIs are described in <a href="#handler-use-servlet">this section</a>.</p>
</div>
<div class="paragraph">
<p>Embedded web applications may also require additional features such as access to Jetty specific APIs, or utility features such as redirection from HTTP to HTTPS, support for <code>gzip</code> content compression, etc.
The Jetty Server Libraries provides a number of out-of-the-box <em>Handler</em>s that implement the most common functionalities and are described in <a href="#handler-use">this section</a>.</p>
</div>
<div class="sect3">
<h4 id="handler-use-util-context"><a class="anchor" href="#handler-use-util-context"></a>ContextHandler</h4>
<div class="paragraph">
<p><code>ContextHandler</code> is a <code>Handler</code> that represents a <em>context</em> for a web application.
It is a <code>HandlerWrapper</code> that performs some action before and after delegating to the nested <code>Handler</code>.</p>
</div>
<div class="paragraph">
<p>The simplest use of <code>ContextHandler</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ShopHandler extends AbstractHandler
{
    @Override
    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)
    {
        baseRequest.setHandled(true);
        // Implement the shop.
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a ContextHandler with contextPath.
ContextHandler context = new ContextHandler();
context.setContextPath("/shop");
context.setHandler(new ShopHandler());

// Link the context to the server.
server.setHandler(context);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ContextHandler /shop
     ShopHandler</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-util-context-collection"><a class="anchor" href="#handler-use-util-context-collection"></a>ContextHandlerCollection</h4>
<div class="paragraph">
<p>Server applications may need to deploy to Jetty more than one web application.</p>
</div>
<div class="paragraph">
<p>Recall from the <a href="#handler">introduction</a> that Jetty offers <code>HandlerCollection</code> and <code>HandlerList</code> that may contain a sequence of children <code>Handler</code>s.
However, both of these have no knowledge of the concept of <em>context</em> and just iterate through the sequence of <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>A better choice for multiple web application is <code>ContextHandlerCollection</code>, that matches a <em>context</em> from either its <em>context path</em> or <em>virtual host</em>, without iterating through the <code>Handler</code>s.</p>
</div>
<div class="paragraph">
<p>If <code>ContextHandlerCollection</code> does not find a match, it just returns.
What happens next depends on the <code>Handler</code> tree structure: other <code>Handler</code>s may be invoked after <code>ContextHandlerCollection</code>, for example <code>DefaultHandler</code> (see <a href="#handler-use-util-default-handler">this section</a>).
Eventually, if <code>Request.setHandled(true)</code> is not called, Jetty returns an HTTP <code>404</code> response to the client.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ShopHandler extends AbstractHandler
{
    @Override
    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)
    {
        baseRequest.setHandled(true);
        // Implement the shop.
    }
}

class RESTHandler extends AbstractHandler
{
    @Override
    public void handle(String target, Request baseRequest, HttpServletRequest request, HttpServletResponse response)
    {
        baseRequest.setHandled(true);
        // Implement the REST APIs.
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
// Link the ContextHandlerCollection to the Server.
server.setHandler(contextCollection);

// Create the context for the shop web application.
ContextHandler shopContext = new ContextHandler("/shop");
shopContext.setHandler(new ShopHandler());
// Add it to ContextHandlerCollection.
contextCollection.addHandler(shopContext);

server.start();

// Create the context for the API web application.
ContextHandler apiContext = new ContextHandler("/api");
apiContext.setHandler(new RESTHandler());
// Web applications can be deployed after the Server is started.
contextCollection.deployHandler(apiContext, Callback.NOOP);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ContextHandlerCollection
     ContextHandler /shop
        ShopHandler
     ContextHandler /api
         RESTHandler</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-util-resource-handler"><a class="anchor" href="#handler-use-util-resource-handler"></a>ResourceHandler&#8201;&#8212;&#8201;Static Content</h4>
<div class="paragraph">
<p>Static content such as images or files (HTML, JavaScript, CSS) can be sent by Jetty very efficiently because Jetty can write the content asynchronously, using direct <code>ByteBuffer</code>s to minimize data copy, and using a memory cache for faster access to the data to send.</p>
</div>
<div class="paragraph">
<p>Being able to write content asynchronously means that if the network gets congested (for example, the client reads the content very slowly) and the server stalls the send of the requested data, then Jetty will wait to resume the send <em>without</em> blocking a thread to finish the send.</p>
</div>
<div class="paragraph">
<p><code>ResourceHandler</code> supports the following features:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Welcome files, for example serving <code>/index.html</code> for request URI <code>/</code></p>
</li>
<li>
<p>Precompressed resources, serving a precompressed <code>/document.txt.gz</code> for request URI <code>/document.txt</code></p>
</li>
<li>
<p><a href="https://tools.ietf.org/html/rfc7233">Range requests</a>, for requests containing the <code>Range</code> header, which allows clients to pause and resume downloads of large files</p>
</li>
<li>
<p>Directory listing, serving a HTML page with the file list of the requested directory</p>
</li>
<li>
<p>Conditional headers, for requests containing the <code>If-Match</code>, <code>If-None-Match</code>, <code>If-Modified-Since</code>, <code>If-Unmodified-Since</code> headers.</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>The number of features supported and the efficiency in sending static content are on the same level as those of common front-end servers used to serve static content such as Nginx or Apache.
Therefore, the traditional architecture where Nginx/Apache was the front-end server used only to send static content and Jetty was the back-end server used only to send dynamic content is somehow obsolete as Jetty can perform efficiently both tasks.
This leads to simpler systems (less components to configure and manage) and more performance (no need to proxy dynamic requests from front-end servers to back-end servers).</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
It is common to use Nginx/Apache as load balancers, or as rewrite/redirect servers.
We typically recommend <a href="https://haproxy.org">HAProxy</a> as load balancer, and Jetty has <a href="#handler-use-util-rewrite-handler">rewrite/redirect features</a> as well.
</td>
</tr>
</table>
</div>
<div class="paragraph">
<p>This is how you configure a <code>ResourceHandler</code> to create a simple file server:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and configure a ResourceHandler.
ResourceHandler handler = new ResourceHandler();
// Configure the directory where static resources are located.
handler.setBaseResource(Resource.newResource("/path/to/static/resources/"));
// Configure directory listing.
handler.setDirectoriesListed(false);
// Configure welcome files.
handler.setWelcomeFiles(new String[]{"index.html"});
// Configure whether to accept range requests.
handler.setAcceptRanges(true);

// Link the context to the server.
server.setHandler(handler);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>If you need to serve static resources from multiple directories:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">ResourceHandler handler = new ResourceHandler();

// For multiple directories, use ResourceCollection.
ResourceCollection directories = new ResourceCollection();
directories.addPath("/path/to/static/resources/");
directories.addPath("/another/path/to/static/resources/");

handler.setBaseResource(directories);</code></pre>
</div>
</div>
<div class="paragraph">
<p>If the resource is not found, <code>ResourceHandler</code> will not call <code>Request.setHandled(true)</code> so what happens next depends on the <code>Handler</code> tree structure.
See also <a href="#handler-use-util-default-handler">how to use</a> <code>DefaultHandler</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-util-gzip-handler"><a class="anchor" href="#handler-use-util-gzip-handler"></a>GzipHandler</h4>
<div class="paragraph">
<p><code>GzipHandler</code> provides supports for automatic decompression of compressed request content and automatic compression of response content.</p>
</div>
<div class="paragraph">
<p><code>GzipHandler</code> is a <code>HandlerWrapper</code> that inspects the request and, if the request matches the <code>GzipHandler</code> configuration, just installs the required components to eventually perform decompression of the request content or compression of the response content.
The decompression/compression is not performed until the web application reads request content or writes response content.</p>
</div>
<div class="paragraph">
<p><code>GzipHandler</code> can be configured at the server level in this way:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create and configure GzipHandler.
GzipHandler gzipHandler = new GzipHandler();
// Only compress response content larger than this.
gzipHandler.setMinGzipSize(1024);
// Do not compress these URI paths.
gzipHandler.setExcludedPaths("/uncompressed");
// Also compress POST responses.
gzipHandler.addIncludedMethods("POST");
// Do not compress these mime types.
gzipHandler.addExcludedMimeTypes("font/ttf");

// Link a ContextHandlerCollection to manage contexts.
ContextHandlerCollection contexts = new ContextHandlerCollection();
gzipHandler.setHandler(contexts);

// Link the GzipHandler to the Server.
server.setHandler(gzipHandler);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 GzipHandler
     ContextHandlerCollection
         ContextHandler 1
        : ...
         ContextHandler N</code></pre>
</div>
</div>
<div class="paragraph">
<p>However, in less common cases, you can configure <code>GzipHandler</code> on a per-context basis, for example because you want to configure <code>GzipHandler</code> with different parameters for each context, or because you want only some contexts to have compression support:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
// Link the ContextHandlerCollection to the Server.
server.setHandler(contextCollection);

// Create the context for the shop web application.
ContextHandler shopContext = new ContextHandler("/shop");
shopContext.setHandler(new ShopHandler());

// You want to gzip the shop web application only.
GzipHandler shopGzipHandler = new GzipHandler();
shopGzipHandler.setHandler(shopContext);

// Add it to ContextHandlerCollection.
contextCollection.addHandler(shopGzipHandler);

// Create the context for the API web application.
ContextHandler apiContext = new ContextHandler("/api");
apiContext.setHandler(new RESTHandler());

// Add it to ContextHandlerCollection.
contextCollection.addHandler(apiContext);</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ContextHandlerCollection
     ContextHandlerCollection
         GzipHandler
            ContextHandler /shop
                ShopHandler
         ContextHandler /api
             RESTHandler</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-util-rewrite-handler"><a class="anchor" href="#handler-use-util-rewrite-handler"></a>RewriteHandler</h4>
<div class="paragraph">
<p><code>RewriteHandler</code> provides support for URL rewriting, very similarly to <a href="https://httpd.apache.org/docs/current/mod/mod_rewrite.html">Apache&#8217;s mod_rewrite</a> or <a href="https://nginx.org/en/docs/http/ngx_http_rewrite_module.html">Nginx rewrite module</a>.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-rewrite&lt;/artifactId&gt;
  &lt;version&gt;10.0.21-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="paragraph">
<p><code>RewriteHandler</code> can be configured with a set of <em>rule</em>s; a <em>rule</em> inspects the request and when it matches it performs some change to the request (for example, changes the URI path, adds/removes headers, etc.).</p>
</div>
<div class="paragraph">
<p>The Jetty Server Libraries provide rules for the most common usages, but you can write your own rules by extending the <code>org.eclipse.jetty.rewrite.handler.Rule</code> class.</p>
</div>
<div class="paragraph">
<p>Please refer to the <code>jetty-rewrite</code> module <a href="https://eclipse.dev/jetty/javadoc/jetty-10/org/eclipse/jetty/rewrite/handler/package-summary.html">javadocs</a> for the complete list of available rules.</p>
</div>
<div class="paragraph">
<p>You typically want to configure <code>RewriteHandler</code> at the server level, although it is possible to configure it on a per-context basis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

RewriteHandler rewriteHandler = new RewriteHandler();
// Compacts URI paths with double slashes, e.g. /ctx//path/to//resource.
rewriteHandler.addRule(new CompactPathRule());
// Rewrites */products/* to */p/*.
rewriteHandler.addRule(new RewriteRegexRule("/(.*)/product/(.*)", "/$1/p/$2"));
// Redirects permanently to a different URI.
RedirectRegexRule redirectRule = new RedirectRegexRule("/documentation/(.*)", "https://docs.domain.com/$1");
redirectRule.setStatusCode(HttpStatus.MOVED_PERMANENTLY_301);
rewriteHandler.addRule(redirectRule);

// Link the RewriteHandler to the Server.
server.setHandler(rewriteHandler);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
// Link the ContextHandlerCollection to the RewriteHandler.
rewriteHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 RewriteHandler
     ContextHandlerCollection
         ContextHandler 1
        : ...
         ContextHandler N</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-util-stats-handler"><a class="anchor" href="#handler-use-util-stats-handler"></a>StatisticsHandler</h4>
<div class="paragraph">
<p><code>StatisticsHandler</code> gathers and exposes a number of statistic values related to request processing such as:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Total number of requests</p>
</li>
<li>
<p>Current number of concurrent requests</p>
</li>
<li>
<p>Minimum, maximum, average and standard deviation of request processing times</p>
</li>
<li>
<p>Number of responses grouped by HTTP code (i.e. how many <code>2xx</code> responses, how many <code>3xx</code> responses, etc.)</p>
</li>
<li>
<p>Total response content bytes</p>
</li>
</ul>
</div>
<div class="paragraph">
<p>Server applications can read these values and use them internally, or expose them via some service, or <a href="../arch/jmx.html" class="xref page">export them to JMX</a>.</p>
</div>
<div class="paragraph">
<p><code>StatisticsHandler</code> can be configured at the server level or at the context level.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
ServerConnector connector = new ServerConnector(server);
server.addConnector(connector);

StatisticsHandler statsHandler = new StatisticsHandler();

// Link the StatisticsHandler to the Server.
server.setHandler(statsHandler);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
// Link the ContextHandlerCollection to the StatisticsHandler.
statsHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 StatisticsHandler
     ContextHandlerCollection
         ContextHandler 1
        : ...
         ContextHandler N</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-util-secure-handler"><a class="anchor" href="#handler-use-util-secure-handler"></a>SecuredRedirectHandler&#8201;&#8212;&#8201;Redirect from HTTP to HTTPS</h4>
<div class="paragraph">
<p><code>SecuredRedirectHandler</code> allows to redirect requests made with the <code>http</code> scheme (and therefore to the clear-text port) to the <code>https</code> scheme (and therefore to the encrypted port).</p>
</div>
<div class="paragraph">
<p>For example a request to <code>http://domain.com:8080/path?param=value</code> is redirected to <code>https://domain.com:8443/path?param=value</code>.</p>
</div>
<div class="paragraph">
<p>Server applications must configure a <code>HttpConfiguration</code> object with the secure scheme and secure port so that <code>SecuredRedirectHandler</code> can build the redirect URI.</p>
</div>
<div class="paragraph">
<p><code>SecuredRedirectHandler</code> is typically configured at the server level, although it can be configured on a per-context basis.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();

// Configure the HttpConfiguration for the clear-text connector.
int securePort = 8443;
HttpConfiguration httpConfig = new HttpConfiguration();
httpConfig.setSecurePort(securePort);

// The clear-text connector.
ServerConnector connector = new ServerConnector(server, new HttpConnectionFactory(httpConfig));
connector.setPort(8080);
server.addConnector(connector);

// Configure the HttpConfiguration for the encrypted connector.
HttpConfiguration httpsConfig = new HttpConfiguration(httpConfig);
// Add the SecureRequestCustomizer because we are using TLS.
httpConfig.addCustomizer(new SecureRequestCustomizer());

// The HttpConnectionFactory for the encrypted connector.
HttpConnectionFactory http11 = new HttpConnectionFactory(httpsConfig);

// Configure the SslContextFactory with the keyStore information.
SslContextFactory.Server sslContextFactory = new SslContextFactory.Server();
sslContextFactory.setKeyStorePath("/path/to/keystore");
sslContextFactory.setKeyStorePassword("secret");

// The ConnectionFactory for TLS.
SslConnectionFactory tls = new SslConnectionFactory(sslContextFactory, http11.getProtocol());

// The encrypted connector.
ServerConnector secureConnector = new ServerConnector(server, tls, http11);
secureConnector.setPort(8443);
server.addConnector(secureConnector);

SecuredRedirectHandler securedHandler = new SecuredRedirectHandler();

// Link the SecuredRedirectHandler to the Server.
server.setHandler(securedHandler);

// Create a ContextHandlerCollection to hold contexts.
ContextHandlerCollection contextCollection = new ContextHandlerCollection();
// Link the ContextHandlerCollection to the StatisticsHandler.
securedHandler.setHandler(contextCollection);

server.start();</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-util-default-handler"><a class="anchor" href="#handler-use-util-default-handler"></a>DefaultHandler</h4>
<div class="paragraph">
<p><code>DefaultHandler</code> is a terminal <code>Handler</code> that always calls <code>Request.setHandled(true)</code> and performs the following:</p>
</div>
<div class="ulist">
<ul>
<li>
<p>Serves the <code>favicon.ico</code> Jetty icon when it is requested</p>
</li>
<li>
<p>Sends a HTTP <code>404</code> response for any other request</p>
</li>
<li>
<p>The HTTP <code>404</code> response content nicely shows a HTML table with all the contexts deployed on the <code>Server</code> instance</p>
</li>
</ul>
</div>
<div class="paragraph">
<p><code>DefaultHandler</code> is best used as the last <code>Handler</code> of a <code>HandlerList</code>, for example:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a HandlerList.
HandlerList handlerList = new HandlerList();

// Add as first a ContextHandlerCollection to manage contexts.
ContextHandlerCollection contexts = new ContextHandlerCollection();
handlerList.addHandler(contexts);

// Add as last a DefaultHandler.
DefaultHandler defaultHandler = new DefaultHandler();
handlerList.addHandler(defaultHandler);

// Link the HandlerList to the Server.
server.setHandler(handlerList);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 HandlerList
     ContextHandlerCollection
        ContextHandler 1
       : ...
        ContextHandler N
     DefaultHandler</code></pre>
</div>
</div>
<div class="paragraph">
<p>In the example above, <code>ContextHandlerCollection</code> will try to match a request to one of the contexts; if the match fails, <code>HandlerList</code> will call the next <code>Handler</code> which is <code>DefaultHandler</code> that will return a HTTP <code>404</code> with an HTML page showing the existing contexts deployed on the <code>Server</code>.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<code>DefaultHandler</code> just sends a nicer HTTP <code>404</code> response in case of wrong requests from clients.
Jetty will send an HTTP <code>404</code> response anyway if <code>DefaultHandler</code> is not used.
</td>
</tr>
</table>
</div>
</div>
</div>
<div class="sect2">
<h3 id="handler-use-servlet"><a class="anchor" href="#handler-use-servlet"></a>Servlet API Handlers</h3>
<div class="sect3">
<h4 id="handler-use-servlet-context"><a class="anchor" href="#handler-use-servlet-context"></a>ServletContextHandler</h4>
<div class="paragraph">
<p><code>Handler</code>s are easy to write, but often web applications have already been written using the Servlet APIs, using <code>Servlet</code>s and <code>Filter</code>s.</p>
</div>
<div class="paragraph">
<p><code>ServletContextHandler</code> is a <code>ContextHandler</code> that provides support for the Servlet APIs and implements the behaviors required by the Servlet specification.</p>
</div>
<div class="paragraph">
<p>The Maven artifact coordinates are:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-xml hljs" data-lang="xml">&lt;dependency&gt;
  &lt;groupId&gt;org.eclipse.jetty&lt;/groupId&gt;
  &lt;artifactId&gt;jetty-servlet&lt;/artifactId&gt;
  &lt;version&gt;10.0.21-SNAPSHOT&lt;/version&gt;
&lt;/dependency&gt;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class ShopCartServlet extends HttpServlet
{
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response)
    {
        // Implement the shop cart functionality.
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a ServletContextHandler with contextPath.
ServletContextHandler context = new ServletContextHandler();
context.setContextPath("/shop");

// Add the Servlet implementing the cart functionality to the context.
ServletHolder servletHolder = context.addServlet(ShopCartServlet.class, "/cart/*");
// Configure the Servlet with init-parameters.
servletHolder.setInitParameter("maxItems", "128");

// Add the CrossOriginFilter to protect from CSRF attacks.
FilterHolder filterHolder = context.addFilter(CrossOriginFilter.class, "/*", EnumSet.of(DispatcherType.REQUEST));
// Configure the filter.
filterHolder.setAsyncSupported(true);

// Link the context to the server.
server.setHandler(context);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>Handler</code> and Servlet components tree structure looks like the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-screen hljs" data-lang="screen">Server
 ServletContextHandler /shop
     <em>ShopCartServlet /cart/*</em>
     <em>CrossOriginFilter /*</em></code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how the Servlet components (they are not <code>Handler</code>s) are represented in <em>italic</em>.</p>
</div>
<div class="paragraph">
<p>Note also how adding a <code>Servlet</code> or a <code>Filter</code> returns a <em>holder</em> object that can be used to specify additional configuration for that particular <code>Servlet</code> or <code>Filter</code>.</p>
</div>
<div class="paragraph">
<p>When a request arrives to <code>ServletContextHandler</code> the request URI will be matched against the <code>Filter</code>s and <code>Servlet</code> mappings and only those that match will process the request, as dictated by the Servlet specification.</p>
</div>
<div class="admonitionblock important">
<table>
<tr>
<td class="icon">
<i class="fa icon-important" title="Important"></i>
</td>
<td class="content">
<code>ServletContextHandler</code> is a terminal <code>Handler</code>, that is it always calls <code>Request.setHandled(true)</code> when invoked.
Server applications must be careful when creating the <code>Handler</code> tree to put <code>ServletContextHandler</code>s as last <code>Handler</code>s in a <code>HandlerList</code> or as children of <code>ContextHandlerCollection</code>.
</td>
</tr>
</table>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-webapp-context"><a class="anchor" href="#handler-use-webapp-context"></a>WebAppContext</h4>
<div class="paragraph">
<p><code>WebAppContext</code> is a <code>ServletContextHandler</code> that auto configures itself by reading a <code>web.xml</code> Servlet configuration file.</p>
</div>
<div class="paragraph">
<p>Server applications can specify a <code>*.war</code> file or a directory with the structure of a <code>*.war</code> file to <code>WebAppContext</code> to deploy a standard Servlet web application packaged as a <code>war</code> (as defined by the Servlet specification).</p>
</div>
<div class="paragraph">
<p>Where server applications using <code>ServletContextHandler</code> must manually invoke methods to add <code>Servlet</code>s and <code>Filter</code>s, <code>WebAppContext</code> reads <code>WEB-INF/web.xml</code> to add <code>Servlet</code>s and <code>Filter</code>s, and also enforces a number of restrictions defined by the Servlet specification, in particular related to class loading.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Create a WebAppContext.
WebAppContext context = new WebAppContext();
// Configure the path of the packaged web application (file or directory).
context.setWar("/path/to/webapp.war");
// Configure the contextPath.
context.setContextPath("/app");

// Link the context to the server.
server.setHandler(context);

server.start();</code></pre>
</div>
</div>
<div id="handler-use-webapp-context-class-loading" class="paragraph">
<div class="title">WebAppContext Class Loading</div>
<p>The Servlet specification requires that a web application class loader must load the web application classes from <code>WEB-INF/classes</code> and <code>WEB_INF/lib</code>.
The web application class loader is special because it behaves differently from typical class loaders: where typical class loaders first delegate to their parent class loader and then try to find the class locally, the web application class loader first tries to find the class locally and then delegates to the parent class loader.
The typical class loading model, parent-first, is <em>inverted</em> for web application class loaders, as they use a child-first model.</p>
</div>
<div class="paragraph">
<p>Furthermore, the Servlet specification requires that web applications cannot load or otherwise access the Servlet container implementation classes, also called <em>server classes</em>.
In the Jetty case, the Servlet specification class <code>javax.servlet.http.HttpServletRequest</code> is implemented by <code>org.eclipse.jetty.server.Request</code>.
Web applications cannot downcast Servlet&#8217;s <code>HttpServletRequest</code> to Jetty&#8217;s <code>Request</code> to access Jetty specific features&#8201;&#8212;&#8201;this ensures maximum web application portability across Servlet container implementations.</p>
</div>
<div class="paragraph">
<p>Lastly, the Servlet specification requires that other classes, also called <em>system classes</em>, such as <code>javax.servlet.http.HttpServletRequest</code> or JDK classes such as <code>java.lang.String</code> or <code>java.sql.Connection</code> cannot be modified by web applications by putting, for example, modified versions of those classes in <code>WEB-INF/classes</code> so that they are loaded first by the web application class loader (instead of the class-path class loader where they are normally loaded from).</p>
</div>
<div class="paragraph">
<p><code>WebAppContext</code> implements this class loader logic using a single class loader, <code>org.eclipse.jetty.webapp.WebAppClassLoader</code>, with filtering capabilities: when it loads a class, it checks whether the class is a <em>system class</em> or a <em>server class</em> and acts according to the Servlet specification.</p>
</div>
<div class="paragraph">
<p>When <code>WebAppClassLoader</code> is asked to load a class, it first tries to find the class locally (since it must use the inverted child-first model); if the class is found, and it is not a <em>system class</em>, the class is loaded; otherwise the class is not found locally.
If the class is not found locally, the parent class loader is asked to load the class; the parent class loader uses the standard parent-first model, so it delegates the class loading to its parent, and so on.
If the class is found, and it is not a <em>server class</em>, the class is loaded; otherwise the class is not found and a <code>ClassNotFoundException</code> is thrown.</p>
</div>
<div class="paragraph">
<p>Unfortunately, the Servlet specification does not define exactly which classes are <em>system classes</em> and which classes are <em>server classes</em>.
However, Jetty picks good defaults and allows server applications to customize <em>system classes</em> and <em>server classes</em> in <code>WebAppContext</code>.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-use-default-servlet"><a class="anchor" href="#handler-use-default-servlet"></a>DefaultServlet&#8201;&#8212;&#8201;Static Content for Servlets</h4>
<div class="paragraph">
<p>If you have a <a href="#handler-use-servlet-context">Servlet web application</a>, you may want to use a <code>DefaultServlet</code> instead of <code>ResourceHandler</code>.
The features are similar, but <code>DefaultServlet</code> is more commonly used to serve static files for Servlet web applications.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">// Create a ServletContextHandler with contextPath.
ServletContextHandler context = new ServletContextHandler();
context.setContextPath("/app");

// Add the DefaultServlet to serve static content.
ServletHolder servletHolder = context.addServlet(DefaultServlet.class, "/");
// Configure the DefaultServlet with init-parameters.
servletHolder.setInitParameter("resourceBase", "/path/to/static/resources/");
servletHolder.setAsyncSupported(true);</code></pre>
</div>
</div>
</div>
</div>
<div class="sect2">
<h3 id="handler-implement"><a class="anchor" href="#handler-implement"></a>Implementing Handler</h3>
<div class="paragraph">
<p>The <code>Handler</code> API consist fundamentally of just one method:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">public void handle(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response)
{
}</code></pre>
</div>
</div>
<div class="paragraph">
<p>The <code>target</code> parameter is an identifier for the resource.
This is normally the URI that is parsed from an HTTP request.
However, a request could be forwarded to either a named resource, in which case <code>target</code> will be the name of the resource, or to a different URI, in which case <code>target</code> will be the new URI.</p>
</div>
<div class="paragraph">
<p>Applications may wrap the request or response (or both) and forward the wrapped request or response to a different URI (which may be possibly handled by a different <code>Handler</code>).
This is the reason why there are two request parameters in the <code>Handler</code> APIs: the first is the unwrapped, original, request that also gives access to Jetty-specific APIs, while the second is the application-wrapped Servlet request.</p>
</div>
<div class="sect3">
<h4 id="handler-impl-hello"><a class="anchor" href="#handler-impl-hello"></a>Hello World Handler</h4>
<div class="paragraph">
<p>A simple "Hello World" <code>Handler</code> is the following:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class HelloWorldHandler extends AbstractHandler
{
    @Override
    public void handle(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws IOException
    {
        // Mark the request as handled by this Handler.
        jettyRequest.setHandled(true);

        response.setStatus(200);
        response.setContentType("text/html; charset=UTF-8");

        // Write a Hello World response.
        response.getWriter().print("" +
            "&lt;!DOCTYPE html&gt;" +
            "&lt;html&gt;" +
            "&lt;head&gt;" +
            "  &lt;title&gt;Jetty Hello World Handler&lt;/title&gt;" +
            "&lt;/head&gt;" +
            "&lt;body&gt;" +
            "  &lt;p&gt;Hello World&lt;/p&gt;" +
            "&lt;/body&gt;" +
            "&lt;/html&gt;" +
            "");
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Set the Hello World Handler.
server.setHandler(new HelloWorldHandler());

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Such a simple <code>Handler</code> extends from <code>AbstractHandler</code> and can access the request and response main features, such as reading request headers and content, or writing response headers and content.</p>
</div>
</div>
<div class="sect3">
<h4 id="handler-impl-filter"><a class="anchor" href="#handler-impl-filter"></a>Filtering Handler</h4>
<div class="paragraph">
<p>A filtering <code>Handler</code> is a handler that perform some modification to the request or response, and then either forwards the request to another <code>Handler</code> or produces an error response:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class FilterHandler extends HandlerWrapper
{
    @Override
    public void handle(String target, Request jettyRequest, HttpServletRequest request, HttpServletResponse response) throws IOException, ServletException
    {
        String path = request.getRequestURI();
        if (path.startsWith("/old_path/"))
        {
            // Rewrite old paths to new paths.
            HttpURI uri = jettyRequest.getHttpURI();
            String newPath = "/new_path/" + path.substring("/old_path/".length());
            HttpURI newURI = HttpURI.build(uri).path(newPath);
            // Modify the request object.
            jettyRequest.setHttpURI(newURI);
        }

        // This Handler is not handling the request, so
        // it does not call jettyRequest.setHandled(true).

        // Forward to the next Handler.
        super.handle(target, jettyRequest, request, response);
    }
}

Server server = new Server();
Connector connector = new ServerConnector(server);
server.addConnector(connector);

// Link the Handlers.
FilterHandler filter = new FilterHandler();
filter.setHandler(new HelloWorldHandler());
server.setHandler(filter);

server.start();</code></pre>
</div>
</div>
<div class="paragraph">
<p>Note how a filtering <code>Handler</code> extends from <code>HandlerWrapper</code> and as such needs another handler to forward the request processing to, and how the two <code>Handler</code>s needs to be linked together to work properly.</p>
</div>
</div>
</div>
<div class="sect2">
<h3 id="security"><a class="anchor" href="#security"></a>Securing HTTP Server Applications</h3>
<div class="paragraph">
<p>TODO</p>
</div>
</div>
<div class="sect2">
<h3 id="application"><a class="anchor" href="#application"></a>Writing HTTP Server Applications</h3>
<div class="paragraph">
<p>Writing HTTP applications is typically simple, especially when using blocking APIs.
However, there are subtle cases where it is worth clarifying what a server application should do to obtain the desired results when run by Jetty.</p>
</div>
<div class="sect3">
<h4 id="application-1xx"><a class="anchor" href="#application-1xx"></a>Sending 1xx Responses</h4>
<div class="paragraph">
<p>The <a href="https://tools.ietf.org/html/rfc7231#section-5.1.1">HTTP/1.1 RFC</a> allows for <code>1xx</code> informational responses to be sent before a real content response.
Unfortunately the servlet specification does not provide a way for these to be sent, so Jetty has had to provide non-standard handling of these headers.</p>
</div>
</div>
<div class="sect3">
<h4 id="application-100"><a class="anchor" href="#application-100"></a>100 Continue</h4>
<div class="paragraph">
<p>The <code>100 Continue</code> response should be sent by the server when a client sends a request with an <code>Expect: 100-continue</code> header, as the client will not send the body of the request until the <code>100 Continue</code> response has been sent.</p>
</div>
<div class="paragraph">
<p>The intent of this feature is to allow a server to inspect the headers and to tell the client to not send a request body that might be too large or insufficiently private or otherwise unable to be handled.</p>
</div>
<div class="paragraph">
<p>Jetty achieves this by waiting until the input stream or reader is obtained by the filter/servlet, before sending the <code>100 Continue</code> response.
Thus a filter/servlet may inspect the headers of a request before getting the input stream and send an error response (or redirect etc.) rather than the 100 continues.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-java hljs" data-lang="java">class Continue100HttpServlet extends HttpServlet
{
    @Override
    protected void service(HttpServletRequest request, HttpServletResponse response) throws IOException
    {
        // Inspect the method and headers.
        boolean isPost = HttpMethod.POST.is(request.getMethod());
        boolean expects100 = HttpHeaderValue.CONTINUE.is(request.getHeader("Expect"));
        long contentLength = request.getContentLengthLong();

        if (isPost &amp;&amp; expects100)
        {
            if (contentLength &gt; 1024 * 1024)
            {
                // Rejects uploads that are too large.
                response.sendError(HttpStatus.PAYLOAD_TOO_LARGE_413);
            }
            else
            {
                // Getting the request InputStream indicates that
                // the application wants to read the request content.
                // Jetty will send the 100 Continue response at this
                // point, and the client will send the request content.
                ServletInputStream input = request.getInputStream();

                // Read and process the request input.
            }
        }
        else
        {
            // Process normal requests.
        }
    }
}</code></pre>
</div>
</div>
</div>
<div class="sect3">
<h4 id="jetty-102-processing"><a class="anchor" href="#jetty-102-processing"></a>102 Processing</h4>
<div class="paragraph">
<p><a href="https://tools.ietf.org/html/rfc2518">RFC 2518</a> defined the <code>102 Processing</code> status code that can be sent:</p>
</div>
<div class="quoteblock">
<blockquote>
when the server has a reasonable expectation that the request will take significant time to complete.
As guidance, if a method is taking longer than 20 seconds (a reasonable, but arbitrary value) to process the server SHOULD return a <code>102 Processing</code> response.
</blockquote>
<div class="attribution">
&#8212; RFC 2518 section 10.1
</div>
</div>
<div class="paragraph">
<p>However, a later update of RFC 2518, <a href="https://tools.ietf.org/html/rfc4918">RFC 4918</a>, removed the <code>102 Processing</code> status code for <a href="https://tools.ietf.org/html/rfc4918#appendix-F.3">"lack of implementation"</a>.</p>
</div>
<div class="paragraph">
<p>Jetty supports the <code>102 Processing</code> status code.
If a request is received with the <code>Expect: 102-processing</code> header, then a filter/servlet may send a <code>102 Processing</code> response (without terminating further processing) by calling <code>response.sendError(102)</code>.</p>
</div>
</div>
</div>
</div>
</div>
<nav class="pagination">
  <span class="prev"><a href="compliance.html">Server Compliance Modes</a></span>
  <span class="next"><a href="http2.html">HTTP/2 Server Library</a></span>
</nav>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <div class="footer-main">
    <figure class="footer-brand">
      <a class="logo" href="https://jetty.org"><img src="../../../../../_/img/jetty-logo.svg" alt="Eclipse Jetty" height="46" width="160"></a>
    </figure>
    <ul class="footer-brand-links">
      <li><a href="../../../../index.html">Docs</a></li>
      <li><a href="../../../../../support.html">Support</a></li>
      <li>Lists: <a href="http://dev.eclipse.org/mhonarc/lists/jetty-users/maillist.html" target="_blank" rel="noopener">users</a> - <a href="http://dev.eclipse.org/mhonarc/lists/jetty-dev/maillist.html" target="_blank" rel="noopener">dev</a></li>
      <li><a href="https://github.com/eclipse/jetty.project" target="_blank" rel="noopener">Source</a></li>
    </ul>
    <p class="footer-brand-follow">
      <a href="https://twitter.com/JettyProject" title="Follow us on X" target="_blank" rel="noopener"><img src="../../../../../_/img/x-logo.svg" alt="X logo" class="logo" width="24"><span class="handle">@JettyProject</span></a>
    </p>
  </div>
  <div class="footer-legal">
    <p>Copyright  2008-2024 Webtide</p>
    <p>The <a href="https://github.com/jetty/jetty.website" target="_blank" rel="noopener">UI for this site</a> is derived from the Antora default UI and is licensed under the MPL-2.0 license. Several icons are imported from <a href="https://primer.style/octicons/" target="_blank" rel="noopener">Octicons</a> and are licensed under the MIT license.</p>
    <p>Eclipse Jetty is a trademarks of the Eclipse Foundation, Inc.</p>
  </div>
  <div class="footer-thanks">
    <p>This project is made possible by Webtide. Additional thanks to the <a href="https://eclipse.org" target="_blank" rel="noopener">Eclipse Foundation</a> for hosting this project.</p>
    <p class="badges">
      <a href="https://webtide.com" title="Development led by Webtide" target="_blank" rel="noopener"><img src="../../../../../_/img/webtide-logo.png" alt="Webtide Logo" width="100"></a>
      <a href="https://jetbrains.com/idea" title="IntelliJ IDEA integration provided by JetBrains" target="_blank" rel="noopener"><img src="../../../../../_/img/jetbrains.svg" alt="Jetbrains Logo" width="24"></a>
    </p>
    <p>Authored in <a href="https://asciidoc.org" target="_blank" rel="noopener">AsciiDoc</a>.<br>Produced by <a href="https://antora.org" target="_blank" rel="noopener">Antora</a> and <a href="https://asciidoctor.org" target="_blank" rel="noopener">Asciidoctor</a>.</p>
  </div>
</footer>
<script id="site-script" src="../../../../../_/js/site.js" data-ui-root-path="../../../../../_"></script>
<script async src="../../../../../_/js/vendor/highlight.js"></script>
<script src="../../../../../_/js/vendor/lunr.js"></script>
<script src="../../../../../_/js/search-ui.js" id="search-ui-script" data-site-root-path="../../../../.." data-snippet-length="100" data-stylesheet="../../../../../_/css/search.css"></script>
<script async src="../../../../../search-index.js"></script>
  </body>
</html>